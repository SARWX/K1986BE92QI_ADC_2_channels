options:
  parameters:
    author: Barry Duggan
    catch_exceptions: 'True'
    category: Custom
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: qpsk_stage6
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: qpsk_stage6
    window_size: 2000,2000
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [96, 592.0]
    rotation: 0
    state: enabled

blocks:
- name: blocks_float_to_complex_0
  id: blocks_float_to_complex
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [888, 376.0]
    rotation: 0
    state: enabled
- name: blocks_null_source_0
  id: blocks_null_source
  parameters:
    affinity: ''
    alias: ''
    bus_structure_source: '[[0,],]'
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_outputs: '1'
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 184.0]
    rotation: 0
    state: true
- name: blocks_null_source_0_0
  id: blocks_null_source
  parameters:
    affinity: ''
    alias: ''
    bus_structure_source: '[[0,],]'
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_outputs: '1'
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 232.0]
    rotation: 0
    state: true
- name: epy_block_0_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport serial\nimport\
      \ serial.tools.list_ports\nimport time\n\nimport numpy as np\nfrom gnuradio\
      \ import gr\nimport pmt\n\nMAX_DAC_NUM = 500   # \u041C\u0430\u043A\u0441\u0438\
      \u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\
      \u0441\u0442\u0432\u043E \u0447\u0438\u0441\u0435\u043B, \u043A\u043E\u0442\u043E\
      \u0440\u043E\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u0437\
      \u0430\u043F\u0438\u0441\u0430\u043D\u043E \u0432 const_signal\nMAX_DAC_VAL\
      \ = 10.0  # \u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\
      \u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u043D\u0430 \u0432\u044B\
      \u0445\u043E\u0434\u0435 \u0426\u0410\u041F\nCHUNK_SIZE = 10     # \u041C\u0430\
      \u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u043A\u043E\u043B\
      \u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0447\u0438\u0441\u0435\u043B \u0432\
      \ \u043E\u0434\u043D\u043E\u0439 \u043A\u043E\u043C\u0430\u043D\u0434\u0435\n\
      USB_PACKET_SIZE = 32 # \u0431\u0430\u0439\u0442\n\nclass ADIBlock(gr.sync_block):\
      \  # other base classes are basic_block, decim_block, interp_block\n    \"\"\
      \"\n    Read data from serial port and forward it to output. \n    portNumber\
      \ is number, you can see in the name of your \n    serial port in device manager,\
      \ like COM16 or COM7 \n    DAC_freq and ADC_freq are specified for 1 channel\n\
      \    \"\"\"\n\n    \n    def __init__(self, portNumber=7, mode = 3, adc_freq\
      \ = 250000, dac_freq = 500000): \n        \"\"\"arguments to this function show\
      \ up as parameters in GRC\"\"\"\n        self.portNumber = portNumber  # \u0421\
      \u043E\u0445\u0440\u0430\u043D\u044F\u0435\u043C \u043D\u043E\u043C\u0435\u0440\
      \ \u043F\u043E\u0440\u0442\u0430       \n        gr.sync_block.__init__(\n \
      \           self,\n            name = 'Analog Digital Interface',   \n     \
      \       in_sig = [np.float32, np.float32],  # \u0412\u0445\u043E\u0434\u044B\
      \n            out_sig = [np.float32, np.float32]  # \u0412\u044B\u0445\u043E\
      \u0434\u044B\n        )\n\n        # \u0420\u0435\u0433\u0438\u0441\u0442\u0440\
      \u0430\u0446\u0438\u044F \u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u043D\
      \u044B\u0445 \u0432\u0445\u043E\u0434\u043D\u044B\u0445 \u0438 \u0432\u044B\u0445\
      \u043E\u0434\u043D\u044B\u0445 \u043F\u043E\u0440\u0442\u043E\u0432\n      \
      \  self.message_port_register_in(pmt.intern('set_const_signal'))\n        self.set_msg_handler(pmt.intern('set_const_signal'),\
      \ self.handle_msg)\n        # self.message_port_register_out(pmt.intern('msg_out'))\n\
      \        self.set_min_output_buffer(2**13)        # 512 - \u043C\u0438\u043D\
      \u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0440\u0430\u0437\u043C\u0435\
      \u0440\n        self.set_max_output_buffer(2**13)  # \u0423\u0441\u0442\u0430\
      \u043D\u043E\u0432\u043A\u0430 \u043C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\
      \u044C\u043D\u043E\u0433\u043E \u0440\u0430\u0437\u043C\u0435\u0440\u0430 \u0431\
      \u0443\u0444\u0435\u0440\u0430\n        self.set_output_multiple(2**13)    \
      \ # \u0423\u0441\u0442\u0430\u043D\u043E\u0432\u043A\u0430 \u0448\u0430\u0433\
      \u0430 \u0434\u0430\u043D\u043D\u044B\u0445\n        # \u0418\u043D\u0438\u0446\
      \u0438\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F \u043F\u0435\u0440\u0435\
      \u043C\u0435\u043D\u043D\u044B\u0445 \u0434\u043B\u044F COM \u043F\u043E\u0440\
      \u0442\u0430\n        self.port = None\n        self.port_name = None\n    \
      \    self.baudrate = 2000000  # \u0417\u0434\u0435\u0441\u044C \u0437\u0430\u0445\
      \u0430\u0440\u0434\u043A\u043E\u0436\u0435\u043D baudrate\n        self.adc_freq\
      \ = adc_freq  \n        self.dac_freq = dac_freq\n        self.mode = mode\n\
      \        self.remaining_data = bytearray(USB_PACKET_SIZE + 1)  # \u0411\u0443\
      \u0444\u0435\u0440 \u0434\u043B\u044F \u043E\u0441\u0442\u0430\u0432\u0448\u0438\
      \u0445\u0441\u044F \u0434\u0430\u043D\u043D\u044B\u0445     0\u043E\u0439 \u0431\
      \u0430\u0439\u0442 - \u0444\u043B\u0430\u0433 (0 - \u0432 \u043C\u0430\u0441\
      \u0441\u0438\u0432\u0435 \u043D\u0435\u0442 \u043F\u043E\u043B\u0435\u0437\u043D\
      \u044B\u0445 \u0434\u0430\u043D\u043D\u044B\u0445, 1 - \u043D\u0430\u0434\u043E\
      \ \u0447\u0438\u0442\u0430\u0442\u044C)\n        \n\n    def open_port(self):\n\
      \        \"\"\"\u041E\u0442\u043A\u0440\u044B\u0432\u0430\u0435\u0442 COM \u043F\
      \u043E\u0440\u0442, \u0435\u0441\u043B\u0438 \u043E\u043D \u0441\u0443\u0449\
      \u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0438 \u043D\u0435 \u0437\u0430\u043D\
      \u044F\u0442.\"\"\"\n        baudrate = 2000000\n        portName = 'COM' +\
      \ str(self.portNumber)\n        # \u041F\u043E\u043B\u0443\u0447\u0430\u0435\
      \u043C \u0441\u043F\u0438\u0441\u043E\u043A \u0434\u043E\u0441\u0442\u0443\u043F\
      \u043D\u044B\u0445 COM \u043F\u043E\u0440\u0442\u043E\u0432\n        available_ports\
      \ = [port.device for port in serial.tools.list_ports.comports()]\n        if\
      \ portName not in available_ports:\n            print(f\"\u041E\u0448\u0438\u0431\
      \u043A\u0430: \u041F\u043E\u0440\u0442 {portName} \u043D\u0435 \u043D\u0430\u0439\
      \u0434\u0435\u043D.\")\n            return\n        try:\n            # \u041F\
      \u044B\u0442\u0430\u0435\u043C\u0441\u044F \u043E\u0442\u043A\u0440\u044B\u0442\
      \u044C \u043F\u043E\u0440\u0442\n            self.port = serial.Serial(portName,\
      \ baudrate, timeout=3.0)\n            # \u0415\u0441\u043B\u0438 \u043F\u043E\
      \u0440\u0442 \u0443\u0436\u0435 \u0431\u044B\u043B \u043E\u0442\u043A\u0440\u044B\
      \u0442, \u0437\u0430\u043A\u0440\u044B\u0432\u0430\u0435\u043C \u0435\u0433\u043E\
      \ \u0438 \u043E\u0442\u043A\u0440\u044B\u0432\u0430\u0435\u043C \u0437\u0430\
      \u043D\u043E\u0432\u043E\n            if self.port.is_open:\n              \
      \  self.port.close()\n                self.port.open()\n            else:\n\
      \                self.port.open()\n            print(f\"\u041F\u043E\u0440\u0442\
      \ {portName} \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043E\u0442\u043A\u0440\
      \u044B\u0442.\")\n        except serial.SerialException as e:\n            #\
      \ \u0415\u0441\u043B\u0438 \u043D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\
      \u044C \u043E\u0442\u043A\u0440\u044B\u0442\u044C \u043F\u043E\u0440\u0442 (\u043D\
      \u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043E\u043D \u0437\u0430\u043D\u044F\
      \u0442), \u0432\u044B\u0432\u043E\u0434\u0438\u043C \u0441\u043E\u043E\u0431\
      \u0449\u0435\u043D\u0438\u0435 \u043E\u0431 \u043E\u0448\u0438\u0431\u043A\u0435\
      \n            print(f\"\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438\
      \ \u043E\u0442\u043A\u0440\u044B\u0442\u0438\u0438 \u043F\u043E\u0440\u0442\u0430\
      \ {portName}: {e}\")\n            self.port = None\n\n\n    def set_mode(self,\
      \ mode_setting):\n        if mode_setting < 4:\n            command = \"mode\
      \ \" + str(mode_setting)  \n        else:\n            command = \"dac_mode\"\
      \n        try:\n            self.port.write(command.encode('ascii'))\n     \
      \       print(f\"\u041E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E\
      : {command}\")\n            time.sleep(0.01)\n        except serial.SerialException\
      \ as e:\n            print(f\"\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\
      \u0438 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0435 \u0434\u0430\u043D\u043D\
      \u044B\u0445: {e}\")\n\n    def set_clock(self, dac_or_adc, adc_freq):\n   \
      \ # dac_or_adc = DAC      dac_or_adc = ADC\n        command = \"clock \" + dac_or_adc\
      \ + str(adc_freq)  \n        try:\n            self.port.write(command.encode('ascii'))\n\
      \            print(f\"\u041E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\
      \u043E: {command}\")\n            time.sleep(0.01)\n        except serial.SerialException\
      \ as e:\n            print(f\"\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\
      \u0438 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0435 \u0434\u0430\u043D\u043D\
      \u044B\u0445: {e}\")\n\n\n    def handle_msg(self, msg):\n        \"\"\"\u041E\
      \u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u0432\u0445\u043E\u0434\u043D\
      \u044B\u0445 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0439.\"\"\"\n\
      \        # \u041F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\
      \u043D\u0438\u0435 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u044F \u0432\
      \ \u0441\u043F\u0438\u0441\u043E\u043A \u0447\u0438\u0441\u0435\u043B \u0441\
      \ \u043F\u043B\u0430\u0432\u0430\u044E\u0449\u0435\u0439 \u0437\u0430\u043F\u044F\
      \u0442\u043E\u0439\n        numbers = pmt.to_python(msg)        # \u041F\u0440\
      \u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D\u0438\u0435 \u0432\
      \ \u0441\u0442\u0440\u043E\u043A\u0443\n        numbers = [float(x) for x in\
      \ numbers.split()]\n        print(\"\u041E\u0431\u0440\u0430\u0431\u043E\u0442\
      \u043A\u0430 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u044F\")\n   \
      \     if len(numbers) > MAX_DAC_NUM:\n            print(f\"\u041E\u0448\u0438\
      \u0431\u043A\u0430: \u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u043D\u043E\
      \u0433\u043E \u0447\u0438\u0441\u0435\u043B. \u041C\u0430\u043A\u0441\u0438\u043C\
      \u0443\u043C {MAX_DAC_NUM}.\")\n            return\n        if any(val > MAX_DAC_VAL\
      \ for val in numbers):\n            print(f\"\u041E\u0448\u0438\u0431\u043A\u0430\
      : \u0417\u043D\u0430\u0447\u0435\u043D\u0438\u044F \u043D\u0435 \u043C\u043E\
      \u0433\u0443\u0442 \u043F\u0440\u0435\u0432\u044B\u0448\u0430\u0442\u044C {MAX_DAC_VAL}.\"\
      )\n            return\n        # \u041E\u0442\u043A\u0440\u044B\u0442\u0438\u0435\
      \ \u043F\u043E\u0440\u0442\u0430, \u0435\u0441\u043B\u0438 \u0435\u0449\u0435\
      \ \u043D\u0435 \u043E\u0442\u043A\u0440\u044B\u0442\n        if self.port is\
      \ None:\n            self.open_port()\n        if self.port is not None and\
      \ self.port.is_open:\n            # \u0420\u0430\u0437\u0434\u0435\u043B\u0435\
      \u043D\u0438\u0435 \u0434\u0430\u043D\u043D\u044B\u0445 \u043D\u0430 \u043A\u0443\
      \u0441\u043A\u0438 \u043F\u043E 10 \u0447\u0438\u0441\u0435\u043B \u0438 \u043E\
      \u0442\u043F\u0440\u0430\u0432\u043A\u0430\n            for i in range(0, len(numbers),\
      \ CHUNK_SIZE):\n                chunk = numbers[i:i + CHUNK_SIZE]\n        \
      \        command = \"set \" + \" \".join(map(str, chunk))\n                if\
      \ i + CHUNK_SIZE >= len(numbers):\n                    command += \" !\"\n \
      \               try:\n                    self.port.write(command.encode('ascii'))\n\
      \                    print(f\"\u041E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\
      \u043D\u043E: {command}\")\n                    time.sleep(0.01)\n         \
      \       except serial.SerialException as e:\n                    print(f\"\u041E\
      \u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043F\u0440\u0430\
      \u0432\u043A\u0435 \u0434\u0430\u043D\u043D\u044B\u0445: {e}\")\n\n        \
      \    \n    def work(self, input_items, output_items):\n\n        if self.port\
      \ is None:\n            # \u0415\u0441\u043B\u0438 \u043F\u043E\u0440\u0442\
      \ \u043D\u0435 \u043E\u0442\u043A\u0440\u044B\u0442, \u043F\u043E\u043F\u044B\
      \u0442\u0430\u0442\u044C\u0441\u044F \u043E\u0442\u043A\u0440\u044B\u0442\u044C\
      \ \u0435\u0433\u043E\n            self.open_port()\n            if self.adc_freq\
      \ > 0:\n                self.set_clock(\"ADC \", self.adc_freq)\n          \
      \  if self.dac_freq > 0:\n                self.set_clock(\"DAC \", self.dac_freq)\n\
      \            self.set_mode(self.mode)\n\n        # \u0421\u043B\u0443\u0447\u0430\
      \u0439 \u043E\u0431\u044B\u0447\u043D\u043E\u0439 \u0440\u0430\u0431\u043E\u0442\
      \u044B (\u0423\u043F\u043E\u0440 \u043D\u0430 \u0410\u0426\u041F)\n        if\
      \ self.mode < 4:\n            n = 0\n            chunk_size = USB_PACKET_SIZE\n\
      \            output_len = len(output_items[0])\n            data = bytearray(chunk_size)\
      \  # \u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u043C\u0430\u0441\u0441\
      \u0438\u0432\u0430 \u0431\u0430\u0439\u0442\u043E\u0432 \u0434\u043B\u044F \u0447\
      \u0442\u0435\u043D\u0438\u044F \u0434\u0430\u043D\u043D\u044B\u0445\n      \
      \      n_increment = (USB_PACKET_SIZE if self.mode < 3 else (USB_PACKET_SIZE\
      \ // 2))\n\n            while n < (output_len - n_increment):\n            \
      \    chunk_size = USB_PACKET_SIZE\n            \n                # \u041E\u0431\
      \u044A\u0435\u0434\u0438\u043D\u044F\u0435\u043C \u043E\u0441\u0442\u0430\u0442\
      \u043E\u0447\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435 \u0438\u0437\
      \ \u043F\u0440\u0435\u0434\u044B\u0434\u0443\u0449\u0435\u0439 \u0438\u0442\u0435\
      \u0440\u0430\u0446\u0438\u0438 \u0441 \u043D\u043E\u0432\u044B\u043C\u0438\n\
      \                if self.remaining_data[0] == 1:\n                    # data\
      \ = bytearray(chunk_size)  # \u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435\
      \ \u043C\u0430\u0441\u0441\u0438\u0432\u0430 \u0431\u0430\u0439\u0442\u043E\u0432\
      \ \u0434\u043B\u044F \u0447\u0442\u0435\u043D\u0438\u044F \u0434\u0430\u043D\
      \u043D\u044B\u0445\n                    chunk_size = len(self.remaining_data)\
      \ - 1\n                    data = bytearray(chunk_size)\n                  \
      \  data = self.remaining_data[1:]       # \u0421\u043E\u0445\u0440\u0430\u043D\
      \u0438\u0442\u044C \u0434\u0430\u043D\u043D\u044B\u0435 \n                 \
      \   self.remaining_data = bytearray(USB_PACKET_SIZE + 1)  # \u041E\u0447\u0438\
      \u0449\u0430\u0435\u043C \u0431\u0443\u0444\u0435\u0440\n                else:\n\
      \                    data = bytearray(chunk_size)  # \u0421\u043E\u0437\u0434\
      \u0430\u043D\u0438\u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u0430 \u0431\u0430\
      \u0439\u0442\u043E\u0432 \u0434\u043B\u044F \u0447\u0442\u0435\u043D\u0438\u044F\
      \ \u0434\u0430\u043D\u043D\u044B\u0445\n                    self.port.readinto(data)\
      \  # \u0421\u0447\u0438\u0442\u044B\u0432\u0430\u043D\u0438\u0435 \u0434\u0430\
      \u043D\u043D\u044B\u0445 \u043D\u0435\u043F\u043E\u0441\u0440\u0435\u0434\u0441\
      \u0442\u0432\u0435\u043D\u043D\u043E \u0432 \u043C\u0430\u0441\u0441\u0438\u0432\
      \ \u0431\u0430\u0439\u0442\u043E\u0432\n\n                if self.mode < 2:\
      \  # mode can be 0 or 1, \u043E\u0431\u0430 \u0432\u043A\u043B\u044E\u0447\u0430\
      \u044E\u0442 \u0442\u043E\u043B\u044C\u043A\u043E 1 \u043A\u0430\u043D\u0430\
      \u043B \u0410\u0426\u041F\n                    output_items[0][n:n + chunk_size]\
      \ = data[:chunk_size]\n                    n += chunk_size\n               \
      \ else:\n                    # TEST 8 bit\n                    output_items[0][n:n\
      \ + chunk_size // 2] = data[0::2]\n                    output_items[1][n:n +\
      \ chunk_size // 2] = data[1::2]\n                    n += chunk_size // 2\n\n\
      \            # \u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\
      \u0441\u0442\u0430\u0432\u0448\u0435\u0433\u043E\u0441\u044F \u043C\u0435\u0441\
      \u0442\u0430 \u0432 output_items\n            if n < output_len:\n         \
      \       self.port.readinto(data)  # \u0421\u0447\u0438\u0442\u044B\u0432\u0430\
      \u0435\u043C \u0434\u0430\u043D\u043D\u044B\u0435 \u0432 \u043C\u0430\u0441\u0441\
      \u0438\u0432 \u0431\u0430\u0439\u0442\u043E\u0432\n                if self.mode\
      \ < 2:  # mode can be 0 \u0438\u043B\u0438 1, \u043E\u0431\u0430 \u0432\u043A\
      \u043B\u044E\u0447\u0430\u044E\u0442 \u0442\u043E\u043B\u044C\u043A\u043E 1\
      \ \u043A\u0430\u043D\u0430\u043B \u0410\u0426\u041F\n                    bytes_to_copy\
      \ = min(chunk_size, output_len - n)\n                    output_items[0][n:n\
      \ + bytes_to_copy] = data[:bytes_to_copy]\n                    n += bytes_to_copy\n\
      \                    self.remaining_data = data[bytes_to_copy:]  # \u0421\u043E\
      \u0445\u0440\u0430\u043D\u044F\u0435\u043C \u043E\u0441\u0442\u0430\u0432\u0448\
      \u0438\u0435\u0441\u044F \u0434\u0430\u043D\u043D\u044B\u0435\n            \
      \    else:\n                    i = 0\n                    while n < output_len\
      \ and i < chunk_size:\n                        output_items[0][n] = data[i]\
      \ \n                        output_items[1][n] = data[i + 1]\n             \
      \           n += 1\n                        i += 2\n                    self.remaining_data\
      \ = bytearray(USB_PACKET_SIZE - i + 1)\n                    self.remaining_data[1:]\
      \ = data[i:]  # \u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0435\u043C \u043E\
      \u0441\u0442\u0430\u0432\u0448\u0438\u0435\u0441\u044F \u0434\u0430\u043D\u043D\
      \u044B\u0435\n                    self.remaining_data[0] = (0 if (USB_PACKET_SIZE\
      \ - i) == 0 else 1)  # \u0424\u043B\u0430\u0433 \u0437\u0430\u043F\u0440\u043E\
      \u0441\u0430 \u0447\u0442\u0435\u043D\u0438\u044F\n\n            return len(output_items[0])\
      \  # \u0412\u043E\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043C \u043A\u043E\
      \u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043E\u0431\u0440\u0430\u0431\
      \u043E\u0442\u0430\u043D\u043D\u044B\u0445 \u044D\u043B\u0435\u043C\u0435\u043D\
      \u0442\u043E\u0432\n\n        # \u0421\u043B\u0443\u0447\u0430\u0439, \u043A\
      \u043E\u0433\u0434\u0430 mode >= 4 (dac_mode) - \u0443\u043F\u043E\u0440 \u043D\
      \u0430 \u0426\u0410\u041F, \u0410\u0426\u041F \u043E\u0442\u043A\u043B\u044E\
      \u0447\u0435\u043D\n        else:\n            data = bytearray(USB_PACKET_SIZE\
      \ )  # \u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u043C\u0430\u0441\u0441\
      \u0438\u0432\u0430 \u0431\u0430\u0439\u0442\u043E\u0432 \u0434\u043B\u044F \u0447\
      \u0442\u0435\u043D\u0438\u044F \u0434\u0430\u043D\u043D\u044B\u0445\n      \
      \      n = 0\n            remaining_len = 0\n            input_len = min(len(input_items[0]),\
      \ len(input_items[1]))  # \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\
      \u043C \u043C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\u043D\u0443\u044E \u0434\
      \u043B\u0438\u043D\u0443 \u0434\u043B\u044F \u0438\u0437\u0431\u0435\u0436\u0430\
      \u043D\u0438\u044F \u0432\u044B\u0445\u043E\u0434\u0430 \u0437\u0430 \u0433\u0440\
      \u0430\u043D\u0438\u0446\u044B\n\n            # \u0415\u0441\u043B\u0438 \u0435\
      \u0441\u0442\u044C remaining_data, \u043E\u0431\u044A\u0435\u0434\u0438\u043D\
      \u044F\u0435\u043C \u0435\u0433\u043E \u0441 \u0442\u0435\u043A\u0443\u0449\u0438\
      \u043C\u0438 \u0434\u0430\u043D\u043D\u044B\u043C\u0438\n            if self.remaining_data:\n\
      \                remaining_len = len(self.remaining_data)\n                #\
      \ \u0423\u0432\u0435\u043B\u0438\u0447\u0438\u0432\u0430\u0435\u043C \u0440\u0430\
      \u0437\u043C\u0435\u0440 \u0431\u0443\u0444\u0435\u0440\u0430, \u0434\u043E\u0431\
      \u0430\u0432\u043B\u044F\u044F \u0434\u043B\u0438\u043D\u0443 remaining_data\n\
      \                data = self.remaining_data + data[:USB_PACKET_SIZE  - remaining_len]\
      \  # \u041E\u0433\u0440\u0430\u043D\u0438\u0447\u0438\u0432\u0430\u0435\u043C\
      \ data \u043F\u043E \u0440\u0430\u0437\u043C\u0435\u0440\u0443\n           \
      \     self.remaining_data = bytearray()  # \u041E\u0447\u0438\u0449\u0430\u0435\
      \u043C \u0431\u0443\u0444\u0435\u0440 \u043F\u043E\u0441\u043B\u0435 \u043E\u0431\
      \u044A\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u044F\n\n            while\
      \ n < input_len:\n                i = remaining_len  # \u0421\u0431\u0440\u0430\
      \u0441\u044B\u0432\u0430\u0435\u043C \u0438\u043D\u0434\u0435\u043A\u0441 \u0434\
      \u043B\u044F data\n                while i < (USB_PACKET_SIZE ) and n < input_len:\
      \  # \u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C \u0438 n\n     \
      \               value1 = int((input_items[0][n]) * 4000) & 0xFFF  # \u041F\u0440\
      \u0438\u0432\u0435\u0434\u0435\u043D\u0438\u0435 \u043A \u0446\u0435\u043B\u043E\
      \u043C\u0443 \u0447\u0438\u0441\u043B\u0443 \u0438 \u043E\u0433\u0440\u0430\u043D\
      \u0438\u0447\u0435\u043D\u0438\u0435 \u0434\u043E 16 \u0431\u0438\u0442\n  \
      \                  data[i] = value1 & 0xFF  # \u041C\u043B\u0430\u0434\u0448\
      \u0438\u0439 \u0431\u0430\u0439\u0442\n                    data[i + 1] = (value1\
      \ >> 8) & 0xFF  # \u0421\u0442\u0430\u0440\u0448\u0438\u0439 \u0431\u0430\u0439\
      \u0442\n                    i += 2\n                    value2 = int((input_items[1][n])\
      \ * 4000) & 0xFFF  # \u041F\u0440\u0438\u0432\u0435\u0434\u0435\u043D\u0438\u0435\
      \ \u043A \u0446\u0435\u043B\u043E\u043C\u0443 \u0447\u0438\u0441\u043B\u0443\
      \ \u0438 \u043E\u0433\u0440\u0430\u043D\u0438\u0447\u0435\u043D\u0438\u0435\
      \ \u0434\u043E 16 \u0431\u0438\u0442\n                    data[i] = value2 &\
      \ 0xFF  # \u041C\u043B\u0430\u0434\u0448\u0438\u0439 \u0431\u0430\u0439\u0442\
      \n                    data[i + 1] = (value2 >> 8) & 0xFF  # \u0421\u0442\u0430\
      \u0440\u0448\u0438\u0439 \u0431\u0430\u0439\u0442\n                    i +=\
      \ 2\n                    n += 1\n                # \u041E\u0442\u043F\u0440\u0430\
      \u0432\u043B\u044F\u0435\u043C \u0441\u043E\u0431\u0440\u0430\u043D\u043D\u044B\
      \u0435 \u0434\u0430\u043D\u043D\u044B\u0435 \u0432 \u043F\u043E\u0440\u0442\n\
      \                self.port.write(data)  # \u041E\u0442\u043F\u0440\u0430\u0432\
      \u043B\u044F\u0435\u043C \u0442\u043E\u043B\u044C\u043A\u043E \u0437\u0430\u043F\
      \u043E\u043B\u043D\u0435\u043D\u043D\u0443\u044E \u0447\u0430\u0441\u0442\u044C\
      \n                remaining_len = 0\n                data = bytearray(USB_PACKET_SIZE\
      \ )\n            # \u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\
      \u0441\u0442\u0430\u0432\u0448\u0438\u0445\u0441\u044F \u0434\u0430\u043D\u043D\
      \u044B\u0445\n            if n < input_len:\n                remaining_data\
      \ = bytearray()\n                while n < input_len and i < USB_PACKET_SIZE\
      \ :\n                    value1 = int((input_items[0][n]) * 4000) & 0xFFF\n\
      \                    remaining_data.append(value1 & 0xFF)\n                \
      \    remaining_data.append((value1 >> 8) & 0xFF)\n                    i += 2\n\
      \                    value2 = int((input_items[1][n]) * 4000) & 0xFFF\n    \
      \                remaining_data.append(value2 & 0xFF)\n                    remaining_data.append((value2\
      \ >> 8) & 0xFF)\n                    i += 2\n                    n += 1\n  \
      \              # \u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0435\u043C \u043E\
      \u0441\u0442\u0430\u0442\u043E\u0447\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\
      \u044B\u0435 \u0434\u043B\u044F \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\
      \u0433\u043E \u0432\u044B\u0437\u043E\u0432\u0430\n                self.remaining_data\
      \ = remaining_data\n\n            return len(input_items[0])\n"
    adc_freq: 0* 62500
    affinity: ''
    alias: ''
    comment: "mode = 0 \t- 1\u044B\u0439 \u043A\u0430\u043D\u0430\u043B \u0410\u0426\
      \u041F, 1\u044B\u0439 \u043A\u0430\u043D\u0430\u043B \u0426\u0410\u041F \nmode\
      \  = 1\t- 1\u044B\u0439 \u043A\u0430\u043D\u0430\u043B \u0410\u0426\u041F, 2\
      \ \u043A\u0430\u043D\u0430\u043B\u0430 \u0426\u0410\u041F    \nmode  = 2\t-\
      \ 2 \u043A\u0430\u043D\u0430\u043B\u0430 \u0410\u0426\u041F, 1\u044B\u0439 \u043A\
      \u0430\u043D\u0430\u043B\u0430 \u0426\u0410\u041F  \nmode = 3\t- 2 \u043A\u0430\
      \u043D\u0430\u043B\u0430 \u0410\u0426\u041F, 2 \u043A\u0430\u043D\u0430\u043B\
      \u0430 \u0426\u0410\u041F\nmode >= 4\t- dac_mode"
    dac_freq: '0'
    maxoutbuf: '0'
    minoutbuf: '0'
    mode: '3'
    portNumber: '10'
  states:
    _io_cache: ('Analog Digital Interface', 'ADIBlock', [('portNumber', '7'), ('mode',
      '3'), ('adc_freq', '250000'), ('dac_freq', '500000')], [('0', 'float', 1), ('1',
      'float', 1), ('set_const_signal', 'message', 1)], [('0', 'float', 1), ('1',
      'float', 1)], '\n    Read data from serial port and forward it to output. \n    portNumber
      is number, you can see in the name of your \n    serial port in device manager,
      like COM16 or COM7 \n    DAC_freq and ADC_freq are specified for 1 channel\n    ',
      ['adc_freq', 'dac_freq', 'mode', 'portNumber'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [240, 184.0]
    rotation: 0
    state: enabled
- name: epy_block_1_0_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\nimport enum\n\n\n# class Scheduler(enum.Enum):\n# \
      \    first_channel = 0\n#     second_channel = 1\n#     deinit = 2\n\nclass\
      \ blk(gr.sync_block):  # other base classes are basic_block, decim_block, interp_block\n\
      \    \"\"\"Embedded Python Block example - a simple multiply const\"\"\"\n\n\
      \    def __init__(self, example_param=1.0):  # only default arguments here\n\
      \        \"\"\"arguments to this function show up as parameters in GRC\"\"\"\
      \n        gr.sync_block.__init__(\n            self,\n            name='Filter\
      \ IQ QPSK',   # will show up in GRC\n            in_sig=[np.float32, np.float32],\n\
      \            out_sig=[np.float32, np.float32]\n        )\n        # if an attribute\
      \ with the same name as a parameter is found,\n        # a callback is registered\
      \ (properties work, too).\n        self.example_param = example_param\n\n  \
      \  def work(self, input_items, output_items):\n        # WAIT = 10\n\n     \
      \   WAIT = 10 * 8 * 4\n        packet_size_bytes = 10  # \u0420\u0430\u0437\u043C\
      \u0435\u0440 \u043F\u0430\u043A\u0435\u0442\u0430 \u0432 \u0431\u0430\u0439\u0442\
      \u0430\u0445\n        packet_size_bits = packet_size_bytes * 8  # 10 \u0431\u0430\
      \u0439\u0442 = 80 \u0431\u0438\u0442\n        bit_size = 4  # \u0420\u0430\u0437\
      \u043C\u0435\u0440 \u0431\u0438\u0442\u0430 (\u0434\u043B\u044F \u0440\u0430\
      \u0441\u0447\u0435\u0442\u0430 \u0448\u0430\u0433\u0430 \u043F\u0440\u0438 \u0447\
      \u0442\u0435\u043D\u0438\u0438)\n        packet_size_mes = packet_size_bits\
      \ * bit_size  # 10 \u0431\u0430\u0439\u0442 = 80 \u0431\u0438\u0442\n      \
      \  # \"\u041F\u043B\u0430\u043D\u0438\u0440\u043E\u0432\u0449\u0438\u043A\"\
      \ \u0440\u0430\u0441\u043F\u0440\u0435\u0434\u0435\u043B\u044F\u044E\u0449\u0438\
      \u0439 \u043F\u043E \u043A\u0430\u043D\u0430\u043B\u0430\u043C (\u043A\u0442\
      \u043E \u0440\u0430\u043D\u044C\u0448\u0435 0->1, \u0442\u043E\u0442 \u043F\u0435\
      \u0440\u0432\u044B\u0439 \u043A\u0430\u043D\u0430\u043B) \n        # scheduler\
      \ = Scheduler.first_channel\n        scheduler = 0\n\n        # 1 - \u0417\u0430\
      \u043F\u043E\u043B\u043D\u0438\u0442\u044C \u0432\u044B\u0445\u043E\u0434\u043D\
      \u043E\u0439 \u043C\u0430\u0441\u0441\u0438\u0432 \u043D\u0443\u043B\u044F\u043C\
      \u0438\n        output_items[0].fill(0)\n        output_items[1].fill(0)\n \
      \       \n        i = 0\n        j = 0\n\n        exact_num_of_mes_per_bit =\
      \ 4.33\n        count_mes_per_pack = 0\n        prev_start = 0\n\n        output_len\
      \ = len(output_items[0])\n        input_len = len(input_items[0])\n\n      \
      \  # print(input_len, output_len)\n        test_mark = 0\n        \n\n     \
      \   chan_0_start_condition = False\n        chan_0_start_index = 0\n       \
      \ chan_1_start_condition = False\n        chan_1_start_index = 0\n        chan_num_0\
      \ = 0\n        chan_num_1 = 1\n\n        start_condition_found = False  # \u0424\
      \u043B\u0430\u0433, \u043D\u0430\u0439\u0434\u0435\u043D\u043E \u043B\u0438\
      \ start_condition\n        read_started = False  # \u0424\u043B\u0430\u0433\
      , \u043D\u0430\u0447\u0430\u043B\u043E\u0441\u044C \u043B\u0438 \u0447\u0442\
      \u0435\u043D\u0438\u0435\n        bits_read = 0  # \u0421\u0447\u0435\u0442\u0447\
      \u0438\u043A \u043F\u0440\u043E\u0447\u0438\u0442\u0430\u043D\u043D\u044B\u0445\
      \ \u0431\u0438\u0442\u043E\u0432\n\n        # \u041D\u0435 \u043D\u0430\u0434\
      \u043E \u0447\u0438\u0442\u0430\u0442\u044C \u0431\u0443\u0444\u0435\u0440,\
      \ \u0435\u0441\u043B\u0438 \u0432 \u043D\u0435\u0433\u043E \u043D\u0435 \u043C\
      \u043E\u0436\u0435\u0442 \u043F\u043E\u043C\u0435\u0441\u0442\u0438\u0442\u044C\
      \u0441\u044F \u043A\u0430\u043A \u043C\u0438\u043D\u0438\u0443\u043C 1 \u043F\
      \u043E\u043B\u043D\u043E\u0446\u0435\u043D\u043D\u044B\u0439 \u043F\u0430\u043A\
      \u0435\u0442\n        # \u0420\u0430\u0437\u043C\u0435\u0440 \u0431\u0443\u0444\
      \u0435\u0440\u0430 \u043F\u043E\u0447\u0435\u043C\u0443-\u0442\u043E \u043F\u043E\
      \u0441\u0442\u043E\u044F\u043D\u043D\u043E \u043C\u0435\u043D\u044F\u0435\u0442\
      \u0441\u044F \n        if (input_len < WAIT + packet_size_mes):\n          \
      \  return(output_len)\n\n        while i < (input_len - 7):\n            if\
      \ not start_condition_found:\n                # 1 - \u041B\u0438\u0431\u043E\
      \ \u043E\u0434\u043D\u043E\u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E,\
      \ \u043B\u0438\u0431\u043E \u0441 \u0448\u0430\u0433\u043E\u043C \u0432 1 \u043E\
      \u0431\u0430 \u043A\u0430\u043D\u0430\u043B\u0430 \u0434\u043E\u043B\u0436\u043D\
      \u044B \u043F\u0435\u0440\u0435\u0439\u0442\u0438 \u0432 1 \n              \
      \  # 1 - \u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C \u0443\u0441\
      \u043B\u043E\u0432\u0438\u0435: \u043E\u0431\u0430 \u043A\u0430\u043D\u0430\u043B\
      \u0430 \u043F\u043E\u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u0435\u043B\
      \u044C\u043D\u043E \u043F\u0435\u0440\u0435\u0448\u043B\u0438 \u043D\u0430 1\n\
      \                if input_items[0][i] > 0.4:\n                    if chan_0_start_condition\
      \ == False:\n                        chan_0_start_index = (i + 2 + 4)\n    \
      \                    chan_num_0 = scheduler            # \u043A\u0430\u043A\u0438\
      \u043C \u043A\u0430\u043D\u0430\u043B\u043E\u043C \u043D\u0430\u0437\u043D\u0430\
      \u0447\u0435\u043D \u043F\u0435\u0440\u0432\u044B\u0439\n                  \
      \      scheduler += 1\n                    chan_0_start_condition = True\n \
      \               if input_items[1][i] > 0.4:\n                    if chan_1_start_condition\
      \ == False:\n                        chan_1_start_index = (i + 2 + 4)\n    \
      \                    chan_num_1 = scheduler            # \u043A\u0430\u043A\u0438\
      \u043C \u043A\u0430\u043D\u0430\u043B\u043E\u043C \u043D\u0430\u0437\u043D\u0430\
      \u0447\u0435\u043D \u0432\u0442\u043E\u0440\u043E\u0439\n                  \
      \      scheduler += 1\n                    chan_1_start_condition = True\n\n\
      \                if (chan_0_start_condition and chan_1_start_condition):\n \
      \                   if (abs(chan_0_start_index - chan_1_start_index) < 4):\n\
      \                        start_condition_found = True\n                    \
      \    # print(i - test_mark)\n                        read_started = True\n \
      \                       bits_read = 0  # \u0421\u0431\u0440\u0430\u0441\u044B\
      \u0432\u0430\u0435\u043C \u0441\u0447\u0435\u0442\u0447\u0438\u043A \u043F\u0440\
      \u043E\u0447\u0438\u0442\u0430\u043D\u043D\u044B\u0445 \u0431\u0438\u0442\u043E\
      \u0432\n                    else:\n                        chan_0_start_condition\
      \ = False\n                        chan_1_start_condition = False\n        \
      \                # scheduler = Scheduler.first_channel\n                   \
      \     scheduler = 0\n                    # # \u041F\u043E\u0441\u0447\u0438\u0442\
      \u0430\u0435\u043C \u0442\u043E\u0447\u043D\u043E \u0441\u043A\u043E\u043B\u044C\
      \u043A\u043E \u0438\u0437\u043C\u0435\u0440\u0435\u043D\u0438\u0439 \u043F\u0440\
      \u0438\u0445\u043E\u0434\u0438\u0442\u0441\u044F \u043D\u0430 1 \u0431\u0438\
      \u0442\n                    # if prev_start != 0:\n                    #   \
      \  count_mes_per_pack = i - prev_start\n                    #     exact_num_of_mes_per_bit\
      \ = count_mes_per_pack / packet_size_bits\n                    #     print(exact_num_of_mes_per_bit)\n\
      \                    # prev_start = i\n\n                # if input_items[0][i]\
      \ > 0.5 and input_items[1][i] > 0.5:\n                #     start_condition_found\
      \ = True\n                #     read_started = True\n                #     bits_read\
      \ = 0  # \u0421\u0431\u0440\u0430\u0441\u044B\u0432\u0430\u0435\u043C \u0441\
      \u0447\u0435\u0442\u0447\u0438\u043A \u043F\u0440\u043E\u0447\u0438\u0442\u0430\
      \u043D\u043D\u044B\u0445 \u0431\u0438\u0442\u043E\u0432\n            else:\n\
      \                if read_started and (bits_read < packet_size_bits):\n     \
      \               # 2 - \u0427\u0438\u0442\u0430\u0435\u043C \u0431\u0438\u0442\
      \u044B \u0441 \u0442\u0435\u043A\u0443\u0449\u0435\u0433\u043E \u0438\u043D\u0434\
      \u0435\u043A\u0441\u0430 \u0441 \u0448\u0430\u0433\u043E\u043C exact_num_of_mes_per_bit\n\
      \                    if (i - chan_0_start_index) >= 0 and (i - chan_0_start_index)\
      \ % exact_num_of_mes_per_bit < 1.0:\n                        output_items[chan_num_0][j\
      \ // 2] = (1 if input_items[0][i] > 0.5 else 0)\n                        j +=\
      \ 1\n                        bits_read += 1\n                    if (i - chan_1_start_index)\
      \ >= 0 and (i - chan_1_start_index) % exact_num_of_mes_per_bit < 1.0:\n    \
      \                    output_items[chan_num_1][j // 2] = (1 if input_items[1][i]\
      \ > 0.5 else 0)\n                        j += 1\n                        bits_read\
      \ += 1\n                else:\n                    # \u0427\u0442\u0435\u043D\
      \u0438\u0435 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E, \u0441\u0431\
      \u0440\u0430\u0441\u044B\u0432\u0430\u0435\u043C \u0444\u043B\u0430\u0433 \u0438\
      \ \u0438\u0449\u0435\u043C \u043D\u043E\u0432\u043E\u0435 start_condition\n\
      \                    start_condition_found = False\n                    read_started\
      \ = False\n                    chan_0_start_condition = False\n            \
      \        chan_1_start_condition = False\n                    bits_read = 0\n\
      \                    scheduler = 0\n                    j += packet_size_bits\
      \ * 4   # (packet_size_bits * 2)    - \u043D\u0443\u043B\u0438 \u0438 \u043F\
      \u043E\u043B\u0435\u0437\u043D\u0430\u044F \u043D\u0430\u0433\u0440\u0443\u0437\
      \u043A\u0430\n                                                             \
      \               # (+ 1) - 0x3               - \u043D\u0430\u0447\u0430\u043B\
      \u043E \u0444\u0440\u0435\u0439\u043C\u0430\n                              \
      \                                              # (- packet_size_bits)      -\
      \ \u043C\u044B \u0443\u0436\u0435 \u043F\u0435\u0440\u0435\u0434\u0430\u043B\
      \u0438 1 \u043F\u0430\u043A\u0435\u0442 \u0431\u0438\u0442\u043E\u0432, \u043D\
      \u0430\u0434\u043E \u0438\u0445 \u0443\u0447\u0435\u0441\u0442\u044C\n     \
      \               stop_trig = 0\n                    # i += (WAIT / 2)\n     \
      \               while (i < input_len and stop_trig < (WAIT / 2)):\n        \
      \                if ((input_items[0][i] < 0.4) and (input_items[0][i] < 0.4)):\n\
      \                            stop_trig += 1\n                        else:\n\
      \                            # print(\"STOP: \", stop_trig)\n              \
      \              stop_trig = 0\n                        i += 1\n             \
      \       # print(\"END: \", stop_trig)\n                    test_mark = i\n\n\
      \            i += 1  # \u0428\u0430\u0433 \u0432 \u043B\u044E\u0431\u043E\u043C\
      \ \u0441\u043B\u0443\u0447\u0430\u0435\n\n        # output_items[0][0] = 2\n\
      \        # output_items[0][output_len - 1] = 3\n        # print(output_len)\n\
      \        # print(input_len)\n\n        return output_len\n"
    affinity: ''
    alias: ''
    comment: ''
    example_param: '1.0'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Filter IQ QPSK', 'blk', [('example_param', '1.0')], [('0', 'float',
      1), ('1', 'float', 1)], [('0', 'float', 1), ('1', 'float', 1)], 'Embedded Python
      Block example - a simple multiply const', ['example_param'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [176, 792.0]
    rotation: 0
    state: disabled
- name: epy_block_1_0_0_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\nimport time\n\nclass blk(gr.sync_block):  # other base\
      \ classes are basic_block, decim_block, interp_block\n    \"\"\"Embedded Python\
      \ Block example - a simple multiply const\"\"\"\n\n    def __init__(self, modulation_type\
      \ = 0, mode = 0):  # only default arguments here\n        \"\"\"arguments to\
      \ this function show up as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n\
      \            self,\n            name='Extract information IQ',   # will show\
      \ up in GRC\n            in_sig=[np.float32, np.float32],\n            out_sig=[np.float32]\n\
      \        )\n        self.num_good_bytes = 0\n        self.num_bad_bytes = 0\n\
      \        self.modulation_type = modulation_type\n        self.mode = mode  \
      \          # Stream / Messenger\n        self.message = \"\"\n        self.test_complite\
      \ = 0 \n        self.test_start_time = 0\n        self.test_end_time = 0\n\n\
      \    def work(self, input_items, output_items):\n        GOOD_BYTE = \"<\"\n\
      \        res_msec = 0\n        output_len = len(output_items[0])\n        input_len\
      \ = len(input_items[0])\n        packet_size_bytes = 10  # \u0420\u0430\u0437\
      \u043C\u0435\u0440 \u043F\u0430\u043A\u0435\u0442\u0430 \u0432 \u0431\u0430\u0439\
      \u0442\u0430\u0445\n        packet_size_bits = packet_size_bytes * 8  # 10 \u0431\
      \u0430\u0439\u0442 = 80 \u0431\u0438\u0442\n        i = 0\n        j = 0\n\n\
      \        while i < output_len - packet_size_bytes * 8:\n            # 1 - \u043F\
      \u0440\u043E\u0447\u0438\u0442\u0430\u0442\u044C \u043F\u0430\u043A\u0435\u0442\
      :\n            packet_str = \"\"\n            readed_bytes = 0\n\n         \
      \   while (readed_bytes < packet_size_bytes) and (i < (output_len - 8)):\n \
      \               byte = 0\n                # QPSK\n                if self.modulation_type\
      \ == 0:\n                    for n in range(0, 4):\n                       \
      \ byte <<= 2\n                        byte += (1 if input_items[1][i] > 0.5\
      \  else 0)\n                        byte += (1 if input_items[0][i] > 0.5  else\
      \ 0) * 2\n                        i += 1\n                # QAM16\n        \
      \        if self.modulation_type == 1:\n                    for n in range(2):\n\
      \                        byte <<= 4\n                        # \u0420\u0430\u0431\
      \u043E\u0442\u0430 \u0441 input_items[1][i]\n                        byte +=\
      \ (0 if input_items[1][i] < 0.2 else \n                                1 if\
      \ input_items[1][i] < 0.4 else \n                                2 if input_items[1][i]\
      \ < 0.8 else 3)\n\n                        # \u0420\u0430\u0431\u043E\u0442\u0430\
      \ \u0441 input_items[0][i]\n                        byte += ((0 if input_items[0][i]\
      \ < 0.2 else \n                                1 if input_items[0][i] < 0.4\
      \ else \n                                2 if input_items[0][i] < 0.8 else 3)\
      \ * 4)\n                        # \u0423\u0432\u0435\u043B\u0438\u0447\u0438\
      \u0432\u0430\u0435\u043C \u0438\u043D\u0434\u0435\u043A\u0441\n            \
      \            i += 1\n\n                output_items[0][j] = byte\n         \
      \       j += 1\n                byte = chr(byte)\n\n                # Messenger\n\
      \                if self.mode == 1:\n                    if byte.isprintable():\n\
      \                        try:\n                            print(byte, end='')\n\
      \                        except UnicodeEncodeError:\n                      \
      \      pass  # \u0418\u0433\u043D\u043E\u0440\u0438\u0440\u0443\u0435\u043C\
      \ \u0441\u0438\u043C\u0432\u043E\u043B, \u0435\u0441\u043B\u0438 \u0435\u0433\
      \u043E \u043D\u0435\u043B\u044C\u0437\u044F \u0432\u044B\u0432\u0435\u0441\u0442\
      \u0438\n\n                # Stream\n\n                # Test\n             \
      \   elif self.mode == 2:\n                    # \u0417\u0410\u041C\u0415\u0420\
      \ \u0421\u041A\u041E\u0420\u041E\u0421\u0422\u0418 \u0418 \u041E\u0428\u0418\
      \u0411\u041A\u0418\n                    if ord(byte) > 0:\n                \
      \        if byte == GOOD_BYTE:\n                            self.num_good_bytes\
      \ += 1\n                        else:\n                            self.num_bad_bytes\
      \ += 1\n                        if self.test_start_time == 0:\n            \
      \                self.test_start_time = time.time()\n\n            if self.num_good_bytes\
      \ > 100000 and self.test_complite == 0:\n                self.test_end_time\
      \ = time.time()\n                print(\"\\n\")\n                print(\"Bitrate:\\\
      t\\t\\t\\t\", int(self.num_good_bytes / (self.test_end_time - self.test_start_time)),\
      \ \" Bytes/s\")\n                print(\"BER (bit error ratio):\\t\", round((self.num_bad_bytes\
      \ / (self.num_good_bytes + self.num_bad_bytes)) * 100, 2) , \" %\")\n      \
      \          self.test_complite = 1\n\n        return output_len\n"
    affinity: ''
    alias: ''
    comment: "modulation_type = 0\t- QPSK\nmodulation_type = 1\t- QAM16\n\nmode =\
      \ 0 \t- stream\nmode = 1 \t- messenger\nmode = 2 \t- test"
    maxoutbuf: '0'
    minoutbuf: '0'
    mode: '1'
    modulation_type: '0'
  states:
    _io_cache: ('Extract information IQ', 'blk', [('modulation_type', '0'), ('mode',
      '0')], [('0', 'float', 1), ('1', 'float', 1)], [('0', 'float', 1)], 'Embedded
      Python Block example - a simple multiply const', ['mode', 'modulation_type'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [880, 208.0]
    rotation: 0
    state: enabled
- name: epy_block_1_0_0_1
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\nimport enum\n\n\n# class Scheduler(enum.Enum):\n# \
      \    first_channel = 0\n#     second_channel = 1\n#     deinit = 2\n\nclass\
      \ blk(gr.sync_block):  # other base classes are basic_block, decim_block, interp_block\n\
      \    \"\"\"Embedded Python Block example - a simple multiply const\"\"\"\n\n\
      \    def __init__(self, modulation_type = 0):  # only default arguments here\n\
      \        \"\"\"arguments to this function show up as parameters in GRC\"\"\"\
      \n        gr.sync_block.__init__(\n            self,\n            name='Filter\
      \ IQ',   # will show up in GRC\n            in_sig=[np.float32, np.float32],\n\
      \            out_sig=[np.float32, np.float32]\n        )\n        # self.set_min_output_buffer(2**13)\
      \        # 512 - \u043C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\u043D\u044B\
      \u0439 \u0440\u0430\u0437\u043C\u0435\u0440\n        # # self.set_max_output_buffer(2**9)\
      \  # \u0423\u0441\u0442\u0430\u043D\u043E\u0432\u043A\u0430 \u043C\u0430\u043A\
      \u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0433\u043E \u0440\u0430\u0437\
      \u043C\u0435\u0440\u0430 \u0431\u0443\u0444\u0435\u0440\u0430\n        # self.set_output_multiple(2**13)\
      \     # \u0423\u0441\u0442\u0430\u043D\u043E\u0432\u043A\u0430 \u0448\u0430\u0433\
      \u0430 \u0434\u0430\u043D\u043D\u044B\u0445\n\n        # if an attribute with\
      \ the same name as a parameter is found,\n        # a callback is registered\
      \ (properties work, too).\n        self.modulation_type = modulation_type\n\n\
      \    def work(self, input_items, output_items):\n        # WAIT = 10\n\n   \
      \     cnt_start_cond = 0\n\n        WAIT = 10 * 8 * 4\n        packet_size_bytes\
      \ = 10  # \u0420\u0430\u0437\u043C\u0435\u0440 \u043F\u0430\u043A\u0435\u0442\
      \u0430 \u0432 \u0431\u0430\u0439\u0442\u0430\u0445\n        packet_size_bits\
      \ = packet_size_bytes * 8  # 10 \u0431\u0430\u0439\u0442 = 80 \u0431\u0438\u0442\
      \n        bit_size = 4  # \u0420\u0430\u0437\u043C\u0435\u0440 \u0431\u0438\u0442\
      \u0430 (\u0434\u043B\u044F \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0448\
      \u0430\u0433\u0430 \u043F\u0440\u0438 \u0447\u0442\u0435\u043D\u0438\u0438)\n\
      \        packet_size_mes = packet_size_bits * bit_size  # 10 \u0431\u0430\u0439\
      \u0442 = 80 \u0431\u0438\u0442\n        # \"\u041F\u043B\u0430\u043D\u0438\u0440\
      \u043E\u0432\u0449\u0438\u043A\" \u0440\u0430\u0441\u043F\u0440\u0435\u0434\u0435\
      \u043B\u044F\u044E\u0449\u0438\u0439 \u043F\u043E \u043A\u0430\u043D\u0430\u043B\
      \u0430\u043C (\u043A\u0442\u043E \u0440\u0430\u043D\u044C\u0448\u0435 0->1,\
      \ \u0442\u043E\u0442 \u043F\u0435\u0440\u0432\u044B\u0439 \u043A\u0430\u043D\
      \u0430\u043B) \n        # scheduler = Scheduler.first_channel\n        scheduler\
      \ = 0\n\n        # 1 - \u0417\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u044C\
      \ \u0432\u044B\u0445\u043E\u0434\u043D\u043E\u0439 \u043C\u0430\u0441\u0441\u0438\
      \u0432 \u043D\u0443\u043B\u044F\u043C\u0438\n        output_items[0].fill(0)\n\
      \        output_items[1].fill(0)\n        \n        i = 0\n        j = 0\n\n\
      \        exact_num_of_mes_per_bit = 4.33\n        count_mes_per_pack = 0\n \
      \       prev_start = 0\n\n        output_len = len(output_items[0])\n      \
      \  # print(\"output len = \", output_len)\n        input_len = len(input_items[0])\n\
      \        # print(\"input len = \", input_len)\n\n\n        # print(input_len,\
      \ output_len)\n        test_mark = 0\n        \n\n        chan_0_start_condition\
      \ = False\n        chan_0_start_index = 0\n        chan_1_start_condition =\
      \ False\n        chan_1_start_index = 0\n        chan_num_0 = 0\n        chan_num_1\
      \ = 1\n\n        start_condition_found = False  # \u0424\u043B\u0430\u0433,\
      \ \u043D\u0430\u0439\u0434\u0435\u043D\u043E \u043B\u0438 start_condition\n\
      \        read_started = False  # \u0424\u043B\u0430\u0433, \u043D\u0430\u0447\
      \u0430\u043B\u043E\u0441\u044C \u043B\u0438 \u0447\u0442\u0435\u043D\u0438\u0435\
      \n        bits_read = 0  # \u0421\u0447\u0435\u0442\u0447\u0438\u043A \u043F\
      \u0440\u043E\u0447\u0438\u0442\u0430\u043D\u043D\u044B\u0445 \u0431\u0438\u0442\
      \u043E\u0432\n\n        # \u041D\u0435 \u043D\u0430\u0434\u043E \u0447\u0438\
      \u0442\u0430\u0442\u044C \u0431\u0443\u0444\u0435\u0440, \u0435\u0441\u043B\u0438\
      \ \u0432 \u043D\u0435\u0433\u043E \u043D\u0435 \u043C\u043E\u0436\u0435\u0442\
      \ \u043F\u043E\u043C\u0435\u0441\u0442\u0438\u0442\u044C\u0441\u044F \u043A\u0430\
      \u043A \u043C\u0438\u043D\u0438\u0443\u043C 1 \u043F\u043E\u043B\u043D\u043E\
      \u0446\u0435\u043D\u043D\u044B\u0439 \u043F\u0430\u043A\u0435\u0442\n      \
      \  # \u0420\u0430\u0437\u043C\u0435\u0440 \u0431\u0443\u0444\u0435\u0440\u0430\
      \ \u043F\u043E\u0447\u0435\u043C\u0443-\u0442\u043E \u043F\u043E\u0441\u0442\
      \u043E\u044F\u043D\u043D\u043E \u043C\u0435\u043D\u044F\u0435\u0442\u0441\u044F\
      \ \n        # if (input_len < WAIT + packet_size_mes):\n        #     return(output_len)\n\
      \n        # \u0414\u043B\u044F \u043D\u043E\u0440\u043C\u0430\u043B\u0438\u0437\
      \u0430\u0446\u0438\u0438 \u0431\u0443\u0434\u0435\u043C \u0434\u0435\u043B\u0438\
      \u0442\u044C \u0437\u0430\u043D\u043E\u0441\u0438\u043C\u044B\u0435 \u0437\u043D\
      \u0430\u0447\u0435\u043D\u0438\u044F \u043D\u0430 \u0430\u043C\u043F\u043B\u0438\
      \u0442\u0443\u0434\u0443\n        amplitude = max(input_items[0])\n        #\
      \ \u0410\u043C\u043F\u043B\u0438\u0442\u0443\u0434\u0430 \u043D\u0435 \u0434\
      \u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0435\u043D\u044C\
      \u0448\u0435 0.8\n        # if amplitude < 0.8:\n        if amplitude < 5:\n\
      \            return(output_len)\n            # amplitude = 1.0\n        threshold\
      \ = amplitude * 0.4\n        \n        # print(input_len)\n        while i <\
      \ (input_len - 7):\n            if not start_condition_found:\n            \
      \    # 1 - \u041B\u0438\u0431\u043E \u043E\u0434\u043D\u043E\u0432\u0440\u0435\
      \u043C\u0435\u043D\u043D\u043E, \u043B\u0438\u0431\u043E \u0441 \u0448\u0430\
      \u0433\u043E\u043C \u0432 1 \u043E\u0431\u0430 \u043A\u0430\u043D\u0430\u043B\
      \u0430 \u0434\u043E\u043B\u0436\u043D\u044B \u043F\u0435\u0440\u0435\u0439\u0442\
      \u0438 \u0432 1 \n                # 1 - \u041F\u0440\u043E\u0432\u0435\u0440\
      \u044F\u0435\u043C \u0443\u0441\u043B\u043E\u0432\u0438\u0435: \u043E\u0431\u0430\
      \ \u043A\u0430\u043D\u0430\u043B\u0430 \u043F\u043E\u0441\u043B\u0435\u0434\u043E\
      \u0432\u0430\u0442\u0435\u043B\u044C\u043D\u043E \u043F\u0435\u0440\u0435\u0448\
      \u043B\u0438 \u043D\u0430 1\n                if input_items[0][i] > threshold:\n\
      \                    if chan_0_start_condition == False:\n                 \
      \       chan_0_start_index = (i + 2 + 4)\n                        chan_num_0\
      \ = scheduler            # \u043A\u0430\u043A\u0438\u043C \u043A\u0430\u043D\
      \u0430\u043B\u043E\u043C \u043D\u0430\u0437\u043D\u0430\u0447\u0435\u043D \u043F\
      \u0435\u0440\u0432\u044B\u0439\n                        scheduler += 1\n   \
      \                 chan_0_start_condition = True\n                if input_items[1][i]\
      \ > threshold:\n                    if chan_1_start_condition == False:\n  \
      \                      chan_1_start_index = (i + 2 + 4)\n                  \
      \      chan_num_1 = scheduler            # \u043A\u0430\u043A\u0438\u043C \u043A\
      \u0430\u043D\u0430\u043B\u043E\u043C \u043D\u0430\u0437\u043D\u0430\u0447\u0435\
      \u043D \u0432\u0442\u043E\u0440\u043E\u0439\n                        scheduler\
      \ += 1\n                    chan_1_start_condition = True\n\n              \
      \  if (chan_0_start_condition and chan_1_start_condition):\n               \
      \     if (abs(chan_0_start_index - chan_1_start_index) < 8):\n             \
      \           start_condition_found = True\n                        cnt_start_cond\
      \ += 1\n                        read_started = True\n                      \
      \  bits_read = 0  # \u0421\u0431\u0440\u0430\u0441\u044B\u0432\u0430\u0435\u043C\
      \ \u0441\u0447\u0435\u0442\u0447\u0438\u043A \u043F\u0440\u043E\u0447\u0438\u0442\
      \u0430\u043D\u043D\u044B\u0445 \u0431\u0438\u0442\u043E\u0432\n            \
      \        else:\n                        chan_0_start_condition = False\n   \
      \                     chan_1_start_condition = False\n                     \
      \   scheduler = 0\n            else:\n                if read_started and (bits_read\
      \ < packet_size_bits):\n                    # 2 - \u0427\u0438\u0442\u0430\u0435\
      \u043C \u0431\u0438\u0442\u044B \u0441 \u0442\u0435\u043A\u0443\u0449\u0435\u0433\
      \u043E \u0438\u043D\u0434\u0435\u043A\u0441\u0430 \u0441 \u0448\u0430\u0433\u043E\
      \u043C exact_num_of_mes_per_bit\n                    if (i - chan_0_start_index)\
      \ >= 0 and (i - chan_0_start_index) % exact_num_of_mes_per_bit < 1.0:\n    \
      \                    # output_items[chan_num_0][j // 2] = (1 if input_items[0][i]\
      \ > 0.5 else 0)\n                        output_items[chan_num_0][j // 2] =\
      \ (input_items[0][i] / amplitude)\n                        j += 1\n        \
      \                bits_read += (self.modulation_type + 1)\n                 \
      \   if (i - chan_1_start_index) >= 0 and (i - chan_1_start_index) % exact_num_of_mes_per_bit\
      \ < 1.0:\n                        # output_items[chan_num_1][j // 2] = (1 if\
      \ input_items[1][i] > 0.5 else 0)\n                        output_items[chan_num_1][j\
      \ // 2] = (input_items[1][i] / amplitude)\n                        j += 1\n\
      \                        bits_read += (self.modulation_type + 1)\n         \
      \               # print(bits_read, i)\n                else:\n             \
      \       # \u0427\u0442\u0435\u043D\u0438\u0435 \u0437\u0430\u0432\u0435\u0440\
      \u0448\u0435\u043D\u043E, \u0441\u0431\u0440\u0430\u0441\u044B\u0432\u0430\u0435\
      \u043C \u0444\u043B\u0430\u0433 \u0438 \u0438\u0449\u0435\u043C \u043D\u043E\
      \u0432\u043E\u0435 start_condition\n                    # print(\"ENDED! i =\
      \ \", i)\n                    start_condition_found = False\n              \
      \      read_started = False\n                    chan_0_start_condition = False\n\
      \                    chan_1_start_condition = False\n                    bits_read\
      \ = 0\n                    scheduler = 0\n                    j += int(packet_size_bits\
      \ * 4 / (self.modulation_type + 1))   # (packet_size_bits * 2)    - \u043D\u0443\
      \u043B\u0438 \u0438 \u043F\u043E\u043B\u0435\u0437\u043D\u0430\u044F \u043D\u0430\
      \u0433\u0440\u0443\u0437\u043A\u0430\n                                     \
      \                                       # (+ 1) - 0x3               - \u043D\
      \u0430\u0447\u0430\u043B\u043E \u0444\u0440\u0435\u0439\u043C\u0430\n      \
      \                                                                      # (-\
      \ packet_size_bits)      - \u043C\u044B \u0443\u0436\u0435 \u043F\u0435\u0440\
      \u0435\u0434\u0430\u043B\u0438 1 \u043F\u0430\u043A\u0435\u0442 \u0431\u0438\
      \u0442\u043E\u0432, \u043D\u0430\u0434\u043E \u0438\u0445 \u0443\u0447\u0435\
      \u0441\u0442\u044C\n                    stop_trig = 0\n                    #\
      \ while (i < input_len and (stop_trig < ((WAIT / 2) / (self.modulation_type\
      \ * 3 + 1)))):\n                    while (i < input_len and (stop_trig < (WAIT\
      \ / 2) / (self.modulation_type * 2 + 1))):\n                    # while (i <\
      \ input_len and (stop_trig < 4)):\n                        if ((input_items[0][i]\
      \ < threshold) and (input_items[0][i] < threshold)):\n                     \
      \       stop_trig += 1\n                            # print(\"STOP_TRIG = \"\
      , stop_trig) \n                        else:\n                            #\
      \ print(\"DELETED STOP_TRIG WAS EQUAL = \", stop_trig) \n                  \
      \          stop_trig = 0\n                        i += 1\n                 \
      \   test_mark = i\n                    # print(i)\n            i += 1  # \u0428\
      \u0430\u0433 \u0432 \u043B\u044E\u0431\u043E\u043C \u0441\u043B\u0443\u0447\u0430\
      \u0435\n\n        # print(cnt_start_cond)\n        return output_len\n"
    affinity: ''
    alias: ''
    comment: "modulation_type = 0\t- QPSK\nmodulation_type = 1\t- QAM16"
    maxoutbuf: '0'
    minoutbuf: '0'
    modulation_type: '0'
  states:
    _io_cache: ('Filter IQ', 'blk', [('modulation_type', '0')], [('0', 'float', 1),
      ('1', 'float', 1)], [('0', 'float', 1), ('1', 'float', 1)], 'Embedded Python
      Block example - a simple multiply const', ['modulation_type'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [608, 240.0]
    rotation: 0
    state: enabled
- name: qtgui_const_sink_x_0
  id: qtgui_const_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: '"blue"'
    color10: '"dark blue"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: ''
    grid: 'False'
    gui_hint: 1,0,2,2
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '0'
    marker10: '0'
    marker2: '0'
    marker3: '0'
    marker4: '0'
    marker5: '0'
    marker6: '0'
    marker7: '0'
    marker8: '0'
    marker9: '0'
    name: '""'
    nconnections: '1'
    size: '10000'
    style1: '0'
    style10: '0'
    style2: '0'
    style3: '0'
    style4: '0'
    style5: '0'
    style6: '0'
    style7: '0'
    style8: '0'
    style9: '0'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_NORM
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    xmax: '1.5'
    xmin: '-0.5'
    ymax: '1.5'
    ymin: '-0.5'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1088, 376.0]
    rotation: 0
    state: enabled
- name: qtgui_time_sink_x_0_2
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: 0,0,1,4
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '""'
    nconnections: '1'
    size: 1024*4
    srate: '100000'
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_NORM
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: float
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '256'
    ymin: '0'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1080, 200.0]
    rotation: 0
    state: enabled
- name: qtgui_time_sink_x_0_2_1
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'False'
    grid: 'False'
    gui_hint: 1,2,2,2
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '""'
    nconnections: '2'
    size: 1024*4
    srate: '100000'
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_NORM
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: float
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '0'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [880, 88.0]
    rotation: 0
    state: enabled
- name: qtgui_time_sink_x_0_2_1_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'False'
    grid: 'False'
    gui_hint: ''
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '""'
    nconnections: '2'
    size: 1024*4
    srate: '100000'
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: float
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '0'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [600, 120.0]
    rotation: 0
    state: enabled

connections:
- [blocks_float_to_complex_0, '0', qtgui_const_sink_x_0, '0']
- [blocks_null_source_0, '0', epy_block_0_0, '0']
- [blocks_null_source_0_0, '0', epy_block_0_0, '1']
- [epy_block_0_0, '0', epy_block_1_0_0_1, '0']
- [epy_block_0_0, '0', qtgui_time_sink_x_0_2_1_0, '0']
- [epy_block_0_0, '1', epy_block_1_0_0_1, '1']
- [epy_block_0_0, '1', qtgui_time_sink_x_0_2_1_0, '1']
- [epy_block_1_0_0_0, '0', qtgui_time_sink_x_0_2, '0']
- [epy_block_1_0_0_1, '0', blocks_float_to_complex_0, '0']
- [epy_block_1_0_0_1, '0', epy_block_1_0_0_0, '0']
- [epy_block_1_0_0_1, '0', qtgui_time_sink_x_0_2_1, '0']
- [epy_block_1_0_0_1, '1', blocks_float_to_complex_0, '1']
- [epy_block_1_0_0_1, '1', epy_block_1_0_0_0, '1']
- [epy_block_1_0_0_1, '1', qtgui_time_sink_x_0_2_1, '1']

metadata:
  file_format: 1
  grc_version: 3.10.8.0
