options:
  parameters:
    author: Barry Duggan
    catch_exceptions: 'True'
    category: Custom
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: qpsk_stage6
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: qpsk_stage6
    window_size: 2000,2000
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [136, 32.0]
    rotation: 0
    state: enabled

blocks:
- name: blocks_char_to_float_0_0_0
  id: blocks_char_to_float
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    scale: '1'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [536, 400.0]
    rotation: 0
    state: enabled
- name: blocks_char_to_float_0_0_0_0
  id: blocks_char_to_float
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    scale: '4'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1064, 256.0]
    rotation: 0
    state: enabled
- name: blocks_char_to_float_0_0_0_1
  id: blocks_char_to_float
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    scale: '4'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1072, 320.0]
    rotation: 0
    state: enabled
- name: blocks_null_sink_0
  id: blocks_null_sink
  parameters:
    affinity: ''
    alias: ''
    bus_structure_sink: '[[0,],]'
    comment: ''
    num_inputs: '1'
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1536, 296.0]
    rotation: 0
    state: true
- name: blocks_null_sink_0_0
  id: blocks_null_sink
  parameters:
    affinity: ''
    alias: ''
    bus_structure_sink: '[[0,],]'
    comment: ''
    num_inputs: '1'
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1536, 328.0]
    rotation: 0
    state: true
- name: blocks_pack_k_bits_bb_0
  id: blocks_pack_k_bits_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    k: '2'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [704, 256.0]
    rotation: 0
    state: enabled
- name: blocks_pack_k_bits_bb_0_0
  id: blocks_pack_k_bits_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    k: '2'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [704, 320.0]
    rotation: 0
    state: enabled
- name: blocks_stream_demux_0
  id: blocks_stream_demux
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    lengths: (2, 2)
    maxoutbuf: '0'
    minoutbuf: '0'
    num_outputs: '2'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [528, 264.0]
    rotation: 0
    state: enabled
- name: blocks_stream_demux_0_0
  id: blocks_stream_demux
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    lengths: (1, 1)
    maxoutbuf: '0'
    minoutbuf: '0'
    num_outputs: '2'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [712, 24.0]
    rotation: 0
    state: disabled
- name: blocks_unpack_k_bits_bb_0_0
  id: blocks_unpack_k_bits_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    k: '8'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [272, 272.0]
    rotation: 0
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport serial\nimport\
      \ serial.tools.list_ports\nimport time\n\nimport numpy as np\nfrom gnuradio\
      \ import gr\nimport pmt\n\nMAX_DAC_NUM = 500   # \u041C\u0430\u043A\u0441\u0438\
      \u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\
      \u0441\u0442\u0432\u043E \u0447\u0438\u0441\u0435\u043B, \u043A\u043E\u0442\u043E\
      \u0440\u043E\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u0437\
      \u0430\u043F\u0438\u0441\u0430\u043D\u043E \u0432 const_signal\nMAX_DAC_VAL\
      \ = 10.0  # \u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\
      \u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u043D\u0430 \u0432\u044B\
      \u0445\u043E\u0434\u0435 \u0426\u0410\u041F\nCHUNK_SIZE = 10     # \u041C\u0430\
      \u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u043A\u043E\u043B\
      \u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0447\u0438\u0441\u0435\u043B \u0432\
      \ \u043E\u0434\u043D\u043E\u0439 \u043A\u043E\u043C\u0430\u043D\u0434\u0435\n\
      USB_PACKET_SIZE = 32 # \u0431\u0430\u0439\u0442\n# USB_PACKET_SIZE = 256 # \u0431\
      \u0430\u0439\u0442              \u0414\u041B\u042F dac mode\n\n\nclass ADIBlock(gr.sync_block):\
      \  # other base classes are basic_block, decim_block, interp_block\n    \"\"\
      \"\n    Read data from serial port and forward it to output. \n    portNumber\
      \ is number, you can see in the name of your \n    serial port in device manager,\
      \ like COM16 or COM7 \n    \"\"\"\n\n    \n    def __init__(self, portNumber=7,\
      \ mode = 3): \n        \"\"\"arguments to this function show up as parameters\
      \ in GRC\"\"\"\n        self.portNumber = portNumber  # \u0421\u043E\u0445\u0440\
      \u0430\u043D\u044F\u0435\u043C \u043D\u043E\u043C\u0435\u0440 \u043F\u043E\u0440\
      \u0442\u0430\n        # portName = 'COM' + str(portNumber)                 \
      \ # Concatenate string and number\n        \n        gr.sync_block.__init__(\n\
      \            self,\n            name = 'Analog Digital Interface',   \n    \
      \        in_sig = [np.float32, np.float32],                # \u0412\u0445\u043E\
      \u0434\u044B\n            out_sig = [np.float32, np.float32]  # \u0412\u044B\
      \u0445\u043E\u0434\u044B\n        )\n\n        # \u0420\u0435\u0433\u0438\u0441\
      \u0442\u0440\u0430\u0446\u0438\u044F \u0438\u043C\u0435\u043D\u043E\u0432\u0430\
      \u043D\u043D\u044B\u0445 \u0432\u0445\u043E\u0434\u043D\u044B\u0445 \u0438 \u0432\
      \u044B\u0445\u043E\u0434\u043D\u044B\u0445 \u043F\u043E\u0440\u0442\u043E\u0432\
      \n        self.message_port_register_in(pmt.intern('set_const_signal'))\n  \
      \      self.set_msg_handler(pmt.intern('set_const_signal'), self.handle_msg)\n\
      \        # self.message_port_register_out(pmt.intern('msg_out'))\n        self.set_min_output_buffer(2**13)\
      \        # 512 - \u043C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\u043D\u044B\
      \u0439 \u0440\u0430\u0437\u043C\u0435\u0440\n        self.set_max_output_buffer(2**13)\
      \  # \u0423\u0441\u0442\u0430\u043D\u043E\u0432\u043A\u0430 \u043C\u0430\u043A\
      \u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0433\u043E \u0440\u0430\u0437\
      \u043C\u0435\u0440\u0430 \u0431\u0443\u0444\u0435\u0440\u0430\n        self.set_output_multiple(2**13)\
      \     # \u0423\u0441\u0442\u0430\u043D\u043E\u0432\u043A\u0430 \u0448\u0430\u0433\
      \u0430 \u0434\u0430\u043D\u043D\u044B\u0445\n\n         # \u0418\u043D\u0438\
      \u0446\u0438\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F \u043F\u0435\u0440\
      \u0435\u043C\u0435\u043D\u043D\u044B\u0445 \u0434\u043B\u044F COM \u043F\u043E\
      \u0440\u0442\u0430\n        self.port = None\n        self.port_name = None\n\
      \        self.baudrate = 2000000  # \u0417\u0434\u0435\u0441\u044C \u0437\u0430\
      \u0445\u0430\u0440\u0434\u043A\u043E\u0436\u0435\u043D baudrate\n        self.mode\
      \ = mode\n        self.remaining_data = bytearray(USB_PACKET_SIZE + 1)  # \u0411\
      \u0443\u0444\u0435\u0440 \u0434\u043B\u044F \u043E\u0441\u0442\u0430\u0432\u0448\
      \u0438\u0445\u0441\u044F \u0434\u0430\u043D\u043D\u044B\u0445     0\u043E\u0439\
      \ \u0431\u0430\u0439\u0442 - \u0444\u043B\u0430\u0433 (0 - \u0432 \u043C\u0430\
      \u0441\u0441\u0438\u0432\u0435 \u043D\u0435\u0442 \u043F\u043E\u043B\u0435\u0437\
      \u043D\u044B\u0445 \u0434\u0430\u043D\u043D\u044B\u0445, 1 - \u043D\u0430\u0434\
      \u043E \u0447\u0438\u0442\u0430\u0442\u044C)\n        \n    def open_port(self):\n\
      \        \"\"\"\u041E\u0442\u043A\u0440\u044B\u0432\u0430\u0435\u0442 COM \u043F\
      \u043E\u0440\u0442, \u0435\u0441\u043B\u0438 \u043E\u043D \u0441\u0443\u0449\
      \u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0438 \u043D\u0435 \u0437\u0430\u043D\
      \u044F\u0442.\"\"\"\n        baudrate = 2000000\n        portName = 'COM' +\
      \ str(self.portNumber)\n\n        # \u041F\u043E\u043B\u0443\u0447\u0430\u0435\
      \u043C \u0441\u043F\u0438\u0441\u043E\u043A \u0434\u043E\u0441\u0442\u0443\u043F\
      \u043D\u044B\u0445 COM \u043F\u043E\u0440\u0442\u043E\u0432\n        available_ports\
      \ = [port.device for port in serial.tools.list_ports.comports()]\n\n       \
      \ if portName not in available_ports:\n            print(f\"\u041E\u0448\u0438\
      \u0431\u043A\u0430: \u041F\u043E\u0440\u0442 {portName} \u043D\u0435 \u043D\u0430\
      \u0439\u0434\u0435\u043D.\")\n            return\n        \n        try:\n \
      \           # \u041F\u044B\u0442\u0430\u0435\u043C\u0441\u044F \u043E\u0442\u043A\
      \u0440\u044B\u0442\u044C \u043F\u043E\u0440\u0442\n            self.port = serial.Serial(portName,\
      \ baudrate, timeout=3.0)\n            # \u0415\u0441\u043B\u0438 \u043F\u043E\
      \u0440\u0442 \u0443\u0436\u0435 \u0431\u044B\u043B \u043E\u0442\u043A\u0440\u044B\
      \u0442, \u0437\u0430\u043A\u0440\u044B\u0432\u0430\u0435\u043C \u0435\u0433\u043E\
      \ \u0438 \u043E\u0442\u043A\u0440\u044B\u0432\u0430\u0435\u043C \u0437\u0430\
      \u043D\u043E\u0432\u043E\n            if self.port.is_open:\n              \
      \  self.port.close()\n                self.port.open()\n            else:\n\
      \                self.port.open()\n            print(f\"\u041F\u043E\u0440\u0442\
      \ {portName} \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043E\u0442\u043A\u0440\
      \u044B\u0442.\")\n        except serial.SerialException as e:\n            #\
      \ \u0415\u0441\u043B\u0438 \u043D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\
      \u044C \u043E\u0442\u043A\u0440\u044B\u0442\u044C \u043F\u043E\u0440\u0442 (\u043D\
      \u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043E\u043D \u0437\u0430\u043D\u044F\
      \u0442), \u0432\u044B\u0432\u043E\u0434\u0438\u043C \u0441\u043E\u043E\u0431\
      \u0449\u0435\u043D\u0438\u0435 \u043E\u0431 \u043E\u0448\u0438\u0431\u043A\u0435\
      \n            print(f\"\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438\
      \ \u043E\u0442\u043A\u0440\u044B\u0442\u0438\u0438 \u043F\u043E\u0440\u0442\u0430\
      \ {portName}: {e}\")\n            self.port = None\n\n\n    def set_mode(self,\
      \ mode_setting):\n        if mode_setting < 4:\n            command = \"mode\
      \ \" + str(mode_setting)  \n        else:\n            command = \"dac_mode\"\
      \n        try:\n            self.port.write(command.encode('ascii'))\n     \
      \       print(f\"\u041E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E\
      : {command}\")\n            time.sleep(0.01)\n        except serial.SerialException\
      \ as e:\n            print(f\"\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\
      \u0438 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0435 \u0434\u0430\u043D\u043D\
      \u044B\u0445: {e}\")\n\n\n    def handle_msg(self, msg):\n        \"\"\"\u041E\
      \u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u0432\u0445\u043E\u0434\u043D\
      \u044B\u0445 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0439.\"\"\"\n\
      \        # \u041F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\
      \u043D\u0438\u0435 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u044F \u0432\
      \ \u0441\u043F\u0438\u0441\u043E\u043A \u0447\u0438\u0441\u0435\u043B \u0441\
      \ \u043F\u043B\u0430\u0432\u0430\u044E\u0449\u0435\u0439 \u0437\u0430\u043F\u044F\
      \u0442\u043E\u0439\n        numbers = pmt.to_python(msg)        # \u041F\u0440\
      \u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D\u0438\u0435 \u0432\
      \ \u0441\u0442\u0440\u043E\u043A\u0443\n        numbers = [float(x) for x in\
      \ numbers.split()]\n        print(\"AAAAAAAAAAAAAAAAAAAAAA\")\n        # print(numbers[30])\n\
      \n        # if not isinstance(numbers, list):\n        #     print(\"\u041E\u0448\
      \u0438\u0431\u043A\u0430: \u041E\u0436\u0438\u0434\u0430\u043B\u0441\u044F \u0441\
      \u043F\u0438\u0441\u043E\u043A \u0447\u0438\u0441\u0435\u043B.\")\n        #\
      \     return\n\n        if len(numbers) > MAX_DAC_NUM:\n            print(f\"\
      \u041E\u0448\u0438\u0431\u043A\u0430: \u0421\u043B\u0438\u0448\u043A\u043E\u043C\
      \ \u043C\u043D\u043E\u0433\u043E \u0447\u0438\u0441\u0435\u043B. \u041C\u0430\
      \u043A\u0441\u0438\u043C\u0443\u043C {MAX_DAC_NUM}.\")\n            return\n\
      \n        if any(val > MAX_DAC_VAL for val in numbers):\n            print(f\"\
      \u041E\u0448\u0438\u0431\u043A\u0430: \u0417\u043D\u0430\u0447\u0435\u043D\u0438\
      \u044F \u043D\u0435 \u043C\u043E\u0433\u0443\u0442 \u043F\u0440\u0435\u0432\u044B\
      \u0448\u0430\u0442\u044C {MAX_DAC_VAL}.\")\n            return\n\n        #\
      \ \u041E\u0442\u043A\u0440\u044B\u0442\u0438\u0435 \u043F\u043E\u0440\u0442\u0430\
      , \u0435\u0441\u043B\u0438 \u0435\u0449\u0435 \u043D\u0435 \u043E\u0442\u043A\
      \u0440\u044B\u0442\n        if self.port is None:\n            self.open_port()\n\
      \n        if self.port is not None and self.port.is_open:\n            # \u0420\
      \u0430\u0437\u0434\u0435\u043B\u0435\u043D\u0438\u0435 \u0434\u0430\u043D\u043D\
      \u044B\u0445 \u043D\u0430 \u043A\u0443\u0441\u043A\u0438 \u043F\u043E 10 \u0447\
      \u0438\u0441\u0435\u043B \u0438 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0430\
      \n            for i in range(0, len(numbers), CHUNK_SIZE):\n               \
      \ chunk = numbers[i:i + CHUNK_SIZE]\n                command = \"set \" + \"\
      \ \".join(map(str, chunk))\n                if i + CHUNK_SIZE >= len(numbers):\n\
      \                    command += \" !\"\n                \n                try:\n\
      \                    self.port.write(command.encode('ascii'))\n            \
      \        print(f\"\u041E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E\
      : {command}\")\n                    time.sleep(0.01)\n                except\
      \ serial.SerialException as e:\n                    print(f\"\u041E\u0448\u0438\
      \u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\
      \u0435 \u0434\u0430\u043D\u043D\u044B\u0445: {e}\")\n\n\n            \n    def\
      \ work(self, input_items, output_items):\n\n        if self.port is None:\n\
      \            # \u0415\u0441\u043B\u0438 \u043F\u043E\u0440\u0442 \u043D\u0435\
      \ \u043E\u0442\u043A\u0440\u044B\u0442, \u043F\u043E\u043F\u044B\u0442\u0430\
      \u0442\u044C\u0441\u044F \u043E\u0442\u043A\u0440\u044B\u0442\u044C \u0435\u0433\
      \u043E\n            self.open_port()\n            self.set_mode(self.mode)\n\
      \n        # \u0421\u043B\u0443\u0447\u0430\u0439 \u043E\u0431\u044B\u0447\u043D\
      \u043E\u0439 \u0440\u0430\u0431\u043E\u0442\u044B (\u0423\u043F\u043E\u0440\
      \ \u043D\u0430 \u0410\u0426\u041F)\n        if self.mode < 4:\n            n\
      \ = 0\n            chunk_size = USB_PACKET_SIZE\n            output_len = len(output_items[0])\n\
      \            # print (output_len)\n            data = bytearray(chunk_size)\
      \  # \u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u043C\u0430\u0441\u0441\
      \u0438\u0432\u0430 \u0431\u0430\u0439\u0442\u043E\u0432 \u0434\u043B\u044F \u0447\
      \u0442\u0435\u043D\u0438\u044F \u0434\u0430\u043D\u043D\u044B\u0445\n      \
      \      n_increment = (USB_PACKET_SIZE if self.mode < 3 else (USB_PACKET_SIZE\
      \ // 2))\n\n                \n            while n < (output_len - n_increment):\n\
      \                chunk_size = USB_PACKET_SIZE\n            \n              \
      \  # \u041E\u0431\u044A\u0435\u0434\u0438\u043D\u044F\u0435\u043C \u043E\u0441\
      \u0442\u0430\u0442\u043E\u0447\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\
      \u0435 \u0438\u0437 \u043F\u0440\u0435\u0434\u044B\u0434\u0443\u0449\u0435\u0439\
      \ \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0438 \u0441 \u043D\u043E\u0432\
      \u044B\u043C\u0438\n                if self.remaining_data[0] == 1:\n      \
      \              # data = bytearray(chunk_size)  # \u0421\u043E\u0437\u0434\u0430\
      \u043D\u0438\u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u0430 \u0431\u0430\u0439\
      \u0442\u043E\u0432 \u0434\u043B\u044F \u0447\u0442\u0435\u043D\u0438\u044F \u0434\
      \u0430\u043D\u043D\u044B\u0445\n                    chunk_size = len(self.remaining_data)\
      \ - 1\n                    data = bytearray(chunk_size)\n                  \
      \  data = self.remaining_data[1:]       # \u0421\u043E\u0445\u0440\u0430\u043D\
      \u0438\u0442\u044C \u0434\u0430\u043D\u043D\u044B\u0435 \n                 \
      \   # print (data)\n                    # data[-1:] = b'\\x00'\n           \
      \         # print(len(self.remaining_data))\n                    # print(data)\n\
      \                    # print(\"YES\")\n                    # while True:\n \
      \                   #     pass\n                    self.remaining_data = bytearray(USB_PACKET_SIZE\
      \ + 1)  # \u041E\u0447\u0438\u0449\u0430\u0435\u043C \u0431\u0443\u0444\u0435\
      \u0440\n                else:\n                    data = bytearray(chunk_size)\
      \  # \u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u043C\u0430\u0441\u0441\
      \u0438\u0432\u0430 \u0431\u0430\u0439\u0442\u043E\u0432 \u0434\u043B\u044F \u0447\
      \u0442\u0435\u043D\u0438\u044F \u0434\u0430\u043D\u043D\u044B\u0445\n      \
      \              self.port.readinto(data)  # \u0421\u0447\u0438\u0442\u044B\u0432\
      \u0430\u043D\u0438\u0435 \u0434\u0430\u043D\u043D\u044B\u0445 \u043D\u0435\u043F\
      \u043E\u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0435\u043D\u043D\u043E \u0432\
      \ \u043C\u0430\u0441\u0441\u0438\u0432 \u0431\u0430\u0439\u0442\u043E\u0432\n\
      \n                if self.mode < 2:  # mode can be 0 or 1, \u043E\u0431\u0430\
      \ \u0432\u043A\u043B\u044E\u0447\u0430\u044E\u0442 \u0442\u043E\u043B\u044C\u043A\
      \u043E 1 \u043A\u0430\u043D\u0430\u043B \u0410\u0426\u041F\n               \
      \     output_items[0][n:n + chunk_size] = data[:chunk_size]\n              \
      \      n += chunk_size\n                else:\n                    # TEST 8\
      \ bit\n                    output_items[0][n:n + chunk_size // 2] = data[0::2]\n\
      \                    output_items[1][n:n + chunk_size // 2] = data[1::2]\n \
      \                   # output_items[1][n] = b'\\x30'\n                    n +=\
      \ chunk_size // 2\n\n                    # TESST\n\n            # \u041E\u0431\
      \u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0441\u0442\u0430\u0432\u0448\
      \u0435\u0433\u043E\u0441\u044F \u043C\u0435\u0441\u0442\u0430 \u0432 output_items\n\
      \            if n < output_len:\n                self.port.readinto(data)  #\
      \ \u0421\u0447\u0438\u0442\u044B\u0432\u0430\u0435\u043C \u0434\u0430\u043D\u043D\
      \u044B\u0435 \u0432 \u043C\u0430\u0441\u0441\u0438\u0432 \u0431\u0430\u0439\u0442\
      \u043E\u0432\n                if self.mode < 2:  # mode can be 0 \u0438\u043B\
      \u0438 1, \u043E\u0431\u0430 \u0432\u043A\u043B\u044E\u0447\u0430\u044E\u0442\
      \ \u0442\u043E\u043B\u044C\u043A\u043E 1 \u043A\u0430\u043D\u0430\u043B \u0410\
      \u0426\u041F\n                    bytes_to_copy = min(chunk_size, output_len\
      \ - n)\n                    output_items[0][n:n + bytes_to_copy] = data[:bytes_to_copy]\n\
      \                    n += bytes_to_copy\n                    self.remaining_data\
      \ = data[bytes_to_copy:]  # \u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0435\
      \u043C \u043E\u0441\u0442\u0430\u0432\u0448\u0438\u0435\u0441\u044F \u0434\u0430\
      \u043D\u043D\u044B\u0435\n                else:\n                    i = 0\n\
      \                    # print(n)\n                    while n < output_len and\
      \ i < chunk_size:\n                        output_items[0][n] = data[i] \n \
      \                       output_items[1][n] = data[i + 1]\n                 \
      \       n += 1\n                        i += 2\n                    # output_items[1][n-1]\
      \ = 300\n                    self.remaining_data = bytearray(USB_PACKET_SIZE\
      \ - i + 1)\n                    self.remaining_data[1:] = data[i:]  # \u0421\
      \u043E\u0445\u0440\u0430\u043D\u044F\u0435\u043C \u043E\u0441\u0442\u0430\u0432\
      \u0448\u0438\u0435\u0441\u044F \u0434\u0430\u043D\u043D\u044B\u0435\n      \
      \              self.remaining_data[0] = (0 if (USB_PACKET_SIZE - i) == 0 else\
      \ 1)  # \u0424\u043B\u0430\u0433 \u0437\u0430\u043F\u0440\u043E\u0441\u0430\
      \ \u0447\u0442\u0435\u043D\u0438\u044F\n                    # print(n)\n   \
      \                 # print(self.remaining_data)\n\n            return len(output_items[0])\
      \  # \u0412\u043E\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043C \u043A\u043E\
      \u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043E\u0431\u0440\u0430\u0431\
      \u043E\u0442\u0430\u043D\u043D\u044B\u0445 \u044D\u043B\u0435\u043C\u0435\u043D\
      \u0442\u043E\u0432\n\n\n\n\n                # \u0421\u043B\u0443\u0447\u0430\
      \u0439, \u043A\u043E\u0433\u0434\u0430 mode >= 4 (dac_mode) - \u0443\u043F\u043E\
      \u0440 \u043D\u0430 \u0426\u0410\u041F, \u0410\u0426\u041F \u043E\u0442\u043A\
      \u043B\u044E\u0447\u0435\u043D\n        # \u0421\u043B\u0443\u0447\u0430\u0439\
      , \u043A\u043E\u0433\u0434\u0430 mode >= 4 (dac_mode) - \u0443\u043F\u043E\u0440\
      \ \u043D\u0430 \u0426\u0410\u041F, \u0410\u0426\u041F \u043E\u0442\u043A\u043B\
      \u044E\u0447\u0435\u043D\n        else:\n            data = bytearray(USB_PACKET_SIZE\
      \ )  # \u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u043C\u0430\u0441\u0441\
      \u0438\u0432\u0430 \u0431\u0430\u0439\u0442\u043E\u0432 \u0434\u043B\u044F \u0447\
      \u0442\u0435\u043D\u0438\u044F \u0434\u0430\u043D\u043D\u044B\u0445\n      \
      \      n = 0\n            remaining_len = 0\n            input_len = min(len(input_items[0]),\
      \ len(input_items[1]))  # \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\
      \u043C \u043C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\u043D\u0443\u044E \u0434\
      \u043B\u0438\u043D\u0443 \u0434\u043B\u044F \u0438\u0437\u0431\u0435\u0436\u0430\
      \u043D\u0438\u044F \u0432\u044B\u0445\u043E\u0434\u0430 \u0437\u0430 \u0433\u0440\
      \u0430\u043D\u0438\u0446\u044B\n            # print(input_len)\n\n         \
      \   # \u0415\u0441\u043B\u0438 \u0435\u0441\u0442\u044C remaining_data, \u043E\
      \u0431\u044A\u0435\u0434\u0438\u043D\u044F\u0435\u043C \u0435\u0433\u043E \u0441\
      \ \u0442\u0435\u043A\u0443\u0449\u0438\u043C\u0438 \u0434\u0430\u043D\u043D\u044B\
      \u043C\u0438\n            if self.remaining_data:\n                remaining_len\
      \ = len(self.remaining_data)\n                # \u0423\u0432\u0435\u043B\u0438\
      \u0447\u0438\u0432\u0430\u0435\u043C \u0440\u0430\u0437\u043C\u0435\u0440 \u0431\
      \u0443\u0444\u0435\u0440\u0430, \u0434\u043E\u0431\u0430\u0432\u043B\u044F\u044F\
      \ \u0434\u043B\u0438\u043D\u0443 remaining_data\n                data = self.remaining_data\
      \ + data[:USB_PACKET_SIZE  - remaining_len]  # \u041E\u0433\u0440\u0430\u043D\
      \u0438\u0447\u0438\u0432\u0430\u0435\u043C data \u043F\u043E \u0440\u0430\u0437\
      \u043C\u0435\u0440\u0443\n                self.remaining_data = bytearray()\
      \  # \u041E\u0447\u0438\u0449\u0430\u0435\u043C \u0431\u0443\u0444\u0435\u0440\
      \ \u043F\u043E\u0441\u043B\u0435 \u043E\u0431\u044A\u0435\u0434\u0438\u043D\u0435\
      \u043D\u0438\u044F\n\n            while n < input_len:\n                i =\
      \ remaining_len  # \u0421\u0431\u0440\u0430\u0441\u044B\u0432\u0430\u0435\u043C\
      \ \u0438\u043D\u0434\u0435\u043A\u0441 \u0434\u043B\u044F data\n\n         \
      \       while i < (USB_PACKET_SIZE ) and n < input_len:  # \u041F\u0440\u043E\
      \u0432\u0435\u0440\u044F\u0435\u043C \u0438 n\n                    value1 =\
      \ int((input_items[0][n]) * 4000) & 0xFFF  # \u041F\u0440\u0438\u0432\u0435\u0434\
      \u0435\u043D\u0438\u0435 \u043A \u0446\u0435\u043B\u043E\u043C\u0443 \u0447\u0438\
      \u0441\u043B\u0443 \u0438 \u043E\u0433\u0440\u0430\u043D\u0438\u0447\u0435\u043D\
      \u0438\u0435 \u0434\u043E 16 \u0431\u0438\u0442\n                    data[i]\
      \ = value1 & 0xFF  # \u041C\u043B\u0430\u0434\u0448\u0438\u0439 \u0431\u0430\
      \u0439\u0442\n                    data[i + 1] = (value1 >> 8) & 0xFF  # \u0421\
      \u0442\u0430\u0440\u0448\u0438\u0439 \u0431\u0430\u0439\u0442\n            \
      \        i += 2\n                    value2 = int((input_items[1][n]) * 4000)\
      \ & 0xFFF  # \u041F\u0440\u0438\u0432\u0435\u0434\u0435\u043D\u0438\u0435 \u043A\
      \ \u0446\u0435\u043B\u043E\u043C\u0443 \u0447\u0438\u0441\u043B\u0443 \u0438\
      \ \u043E\u0433\u0440\u0430\u043D\u0438\u0447\u0435\u043D\u0438\u0435 \u0434\u043E\
      \ 16 \u0431\u0438\u0442\n                    data[i] = value2 & 0xFF  # \u041C\
      \u043B\u0430\u0434\u0448\u0438\u0439 \u0431\u0430\u0439\u0442\n            \
      \        data[i + 1] = (value2 >> 8) & 0xFF  # \u0421\u0442\u0430\u0440\u0448\
      \u0438\u0439 \u0431\u0430\u0439\u0442\n                    i += 2\n        \
      \            n += 1\n\n                # \u041E\u0442\u043F\u0440\u0430\u0432\
      \u043B\u044F\u0435\u043C \u0441\u043E\u0431\u0440\u0430\u043D\u043D\u044B\u0435\
      \ \u0434\u0430\u043D\u043D\u044B\u0435 \u0432 \u043F\u043E\u0440\u0442\n   \
      \             self.port.write(data)  # \u041E\u0442\u043F\u0440\u0430\u0432\u043B\
      \u044F\u0435\u043C \u0442\u043E\u043B\u044C\u043A\u043E \u0437\u0430\u043F\u043E\
      \u043B\u043D\u0435\u043D\u043D\u0443\u044E \u0447\u0430\u0441\u0442\u044C\n\
      \                remaining_len = 0\n                data = bytearray(USB_PACKET_SIZE\
      \ )\n\n            # \u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430\
      \ \u043E\u0441\u0442\u0430\u0432\u0448\u0438\u0445\u0441\u044F \u0434\u0430\u043D\
      \u043D\u044B\u0445\n            if n < input_len:\n                remaining_data\
      \ = bytearray()\n\n                while n < input_len and i < USB_PACKET_SIZE\
      \ :\n                    value1 = int((input_items[0][n]) * 4000) & 0xFFF\n\
      \                    remaining_data.append(value1 & 0xFF)\n                \
      \    remaining_data.append((value1 >> 8) & 0xFF)\n                    i += 2\n\
      \                    value2 = int((input_items[1][n]) * 4000) & 0xFFF\n    \
      \                remaining_data.append(value2 & 0xFF)\n                    remaining_data.append((value2\
      \ >> 8) & 0xFF)\n                    i += 2\n                    n += 1\n\n\
      \                # \u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0435\u043C \u043E\
      \u0441\u0442\u0430\u0442\u043E\u0447\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\
      \u044B\u0435 \u0434\u043B\u044F \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\
      \u0433\u043E \u0432\u044B\u0437\u043E\u0432\u0430\n                self.remaining_data\
      \ = remaining_data\n\n            return len(input_items[0])\n\n"
    affinity: ''
    alias: ''
    comment: "mode = 0,    // 1\u044B\u0439 \u043A\u0430\u043D\u0430\u043B \u0410\u0426\
      \u041F, 1\u044B\u0439 \u043A\u0430\u043D\u0430\u043B \u0426\u0410\u041F \nmode\
      \  = 1,    // 1\u044B\u0439 \u043A\u0430\u043D\u0430\u043B \u0410\u0426\u041F\
      , 2 \u043A\u0430\u043D\u0430\u043B\u0430 \u0426\u0410\u041F    \nmode  = 2,\
      \    // 2 \u043A\u0430\u043D\u0430\u043B\u0430 \u0410\u0426\u041F, 1\u044B\u0439\
      \ \u043A\u0430\u043D\u0430\u043B\u0430 \u0426\u0410\u041F  \nmode = 3,    //\
      \ 2 \u043A\u0430\u043D\u0430\u043B\u0430 \u0410\u0426\u041F, 2 \u043A\u0430\u043D\
      \u0430\u043B\u0430 \u0426\u0410\u041F\nmode >= 4  // dac_mode"
    maxoutbuf: '0'
    minoutbuf: '0'
    mode: '20'
    portNumber: '7'
  states:
    _io_cache: ('Analog Digital Interface', 'ADIBlock', [('portNumber', '7'), ('mode',
      '3')], [('0', 'float', 1), ('1', 'float', 1), ('set_const_signal', 'message',
      1)], [('0', 'float', 1), ('1', 'float', 1)], '\n    Read data from serial port
      and forward it to output. \n    portNumber is number, you can see in the name
      of your \n    serial port in device manager, like COM16 or COM7 \n    ', ['mode',
      'portNumber'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1320, 280.0]
    rotation: 0
    state: enabled
- name: epy_block_1
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nMessenger\n\"\"\"\n\n#  epy_block_0.py\n#  created 10/17/2019\n\
      \nimport numpy as np\nfrom gnuradio import gr\n\nimport pmt\nimport math\n\n\
      textboxValue = \"\"\n\nclass my_sync_block(gr.sync_block):\n    \"\"\"\n   \
      \ reads input from a message port\n    outputs packets of bytes\n    \"\"\"\n\
      \    def __init__(self, modulation_type = 0):\n        gr.sync_block.__init__(self,\n\
      \            name = \"Messenger\",\n            in_sig = None,\n           \
      \ out_sig = [np.byte])\n        self.message_port_register_in(pmt.intern('msg_in'))\n\
      \        self.message_port_register_out(pmt.intern('clear_input'))\n       \
      \ self.set_msg_handler(pmt.intern('msg_in'), self.handle_msg)\n        # \u041F\
      \u0443\u0431\u043B\u0438\u0447\u043D\u044B\u0435 \u0430\u0442\u0440\u0438\u0431\
      \u0443\u0442\u044B\n        self.modulation_type = modulation_type\n       \
      \ self.cleared = 0\n\n        self.set_min_output_buffer(2**13)        # 512\
      \ - \u043C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0440\
      \u0430\u0437\u043C\u0435\u0440\n        self.set_max_output_buffer(2**13)  #\
      \ \u0423\u0441\u0442\u0430\u043D\u043E\u0432\u043A\u0430 \u043C\u0430\u043A\u0441\
      \u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0433\u043E \u0440\u0430\u0437\u043C\
      \u0435\u0440\u0430 \u0431\u0443\u0444\u0435\u0440\u0430\n        self.set_output_multiple(2**13)\
      \     # \u0423\u0441\u0442\u0430\u043D\u043E\u0432\u043A\u0430 \u0448\u0430\u0433\
      \u0430 \u0434\u0430\u043D\u043D\u044B\u0445\n\n    def handle_msg(self, msg):\n\
      \        global textboxValue\n\n        textboxValue = pmt.symbol_to_string\
      \ (msg)\n        # print (textboxValue)\n    \n    def work(self, input_items,\
      \ output_items):\n        global textboxValue\n\n        PACKET_SIZE = 10\n\
      \        WAIT = 10\n\n        output_len = len(output_items[0])\n        output_items[0].fill(0)\n\
      \n        # get length of string\n        _len = len(textboxValue)\n       \
      \ # \u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C Start condition\n     \
      \   if self.modulation_type == 0:\n            start_condition = 3        #\
      \ \u042D\u0442\u043E 2 \u0435\u0434\u0438\u043D\u0438\u0446\u044B \u043F\u043E\
      \u0434\u0440\u044F\u0434 (2 \u043D\u0430\u0434\u043E, \u0447\u0442\u043E\u0431\
      \u044B \u043D\u0430 \u043E\u0431\u0430 \u043A\u0430\u043D\u0430\u043B\u0430\
      )\n        else:\n            start_condition = 15        # \u042D\u0442\u043E\
      \ \u043F\u043E 2 \u0435\u0434\u0438\u043D\u0438\u0446\u044B \u043F\u043E\u0434\
      \u0440\u044F\u0434 \u043D\u0430 2 \u043A\u0430\u043D\u0430\u043B\u0430\n\n \
      \       pos_send = 0\n        pos_src = 0\n\n\n        if (_len > 0):\n    \
      \        # terminate with LF\n            textboxValue += \"\\n\" \n       \
      \     _len += 1\n\n            # Find good pos_send (not at the start)\n   \
      \         pos_send = int(output_len - (_len * 2 + (_len // 10) + 10))\n\n  \
      \          # divide by packets\n            for packet in range(math.ceil(_len\
      \ / PACKET_SIZE)):\n                # print(packet)\n                # Start\
      \ condition                                             \n                output_items[0][pos_send]\
      \ = start_condition\n                pos_send += 1\n                # Information\n\
      \                for _ in range(PACKET_SIZE):\n                    if pos_src\
      \ < _len:\n                        output_items[0][pos_send] = ord(textboxValue[pos_src])\n\
      \                        pos_send += 1\n                        pos_src += 1\n\
      \                    else:\n                        pos_send += 1\n        \
      \        # Wait\n                # print(pos_send)\n                pos_send\
      \ += WAIT\n            \n            # store elements in output array\n    \
      \        # for x in range(_len):\n            #     output_items[0][x + 1] =\
      \ ord(textboxValue[x])\n            textboxValue = \"\"\n            self.message_port_pub(pmt.intern('clear_input'),\
      \ pmt.intern(''))\n            # print(output_len)\n            # return (pos_send)\n\
      \            self.cleared = 0\n            return (output_len)\n        elif\
      \ self.cleared == 1:\n            return (0)\n        else:\n            self.cleared\
      \ = 1\n            return(output_len)"
    affinity: ''
    alias: ''
    comment: "modulation_type = 0\t- QPSK\nmodulation_type = 0\t- QAM16"
    maxoutbuf: '0'
    minoutbuf: '0'
    modulation_type: '1'
  states:
    _io_cache: ('Messenger', 'my_sync_block', [('modulation_type', '0')], [('msg_in',
      'message', 1)], [('0', 'byte', 1), ('clear_input', 'message', 1)], '\n    reads
      input from a message port\n    outputs packets of bytes\n    ', ['modulation_type'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [64, 384.0]
    rotation: 0
    state: enabled
- name: epy_block_1_0_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\n\n# Constants\nWAIT = 10\n\nclass blk(gr.sync_block):\
      \  # other base classes are basic_block, decim_block, interp_block\n    \"\"\
      \"Embedded Python Block example - a simple multiply const\"\"\"\n\n    def __init__(self,\
      \ mode = 0):  # only default arguments here\n        \"\"\"arguments to this\
      \ function show up as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n\
      \            self,\n            name='Test string generator',   # will show\
      \ up in GRC\n            in_sig=[],\n            out_sig=[np.byte]\n       \
      \ )\n        # if an attribute with the same name as a parameter is found,\n\
      \        # a callback is registered (properties work, too).\n        self.mode\
      \ = mode  # QPSK = 0 \u0438\u043B\u0438 QAM16 = 1\n\n    def work(self, input_items,\
      \ output_items):\n        i = 0\n        default_level = \"\\0\" * WAIT\n  \
      \      if self.mode == 0:\n            start_condition = chr(3)        # \u042D\
      \u0442\u043E 2 \u0435\u0434\u0438\u043D\u0438\u0446\u044B \u043F\u043E\u0434\
      \u0440\u044F\u0434 (2 \u043D\u0430\u0434\u043E, \u0447\u0442\u043E\u0431\u044B\
      \ \u043D\u0430 \u043E\u0431\u0430 \u043A\u0430\u043D\u0430\u043B\u0430)\n  \
      \      else:\n            start_condition = chr(15)        # \u042D\u0442\u043E\
      \ \u043F\u043E 2 \u0435\u0434\u0438\u043D\u0438\u0446\u044B \u043F\u043E\u0434\
      \u0440\u044F\u0434 \u043D\u0430 2 \u043A\u0430\u043D\u0430\u043B\u0430\n   \
      \     all_contelation_points = chr(27)\n\n        # information = \"Hello!!!!!\"\
      \n        information = \"<\" * 10\n        # information = all_contelation_points\
      \ * 10\n\n        messege = default_level + start_condition + information\n\
      \        message_bytes = bytes(messege, 'ascii')\n        mes_len = len(messege)\n\
      \        output_len = len(output_items[0])\n        while(i < (output_len -\
      \ mes_len)):\n           # \u041F\u0435\u0440\u0435\u0432\u043E\u0434\u0438\u043C\
      \ \u0431\u0430\u0439\u0442\u044B \u0432 \u0446\u0435\u043B\u044B\u0435 \u0447\
      \u0438\u0441\u043B\u0430 \u0438 \u0437\u0430\u043F\u0438\u0441\u044B\u0432\u0430\
      \u0435\u043C \u0432 \u043C\u0430\u0441\u0441\u0438\u0432\n            output_items[0][i:i\
      \ + mes_len] = np.frombuffer(message_bytes, dtype=np.byte)\n            i +=\
      \ mes_len\n        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    mode: '1'
  states:
    _io_cache: ('Test string generator', 'blk', [('mode', '0')], [], [('0', 'byte',
      1)], 'Embedded Python Block example - a simple multiply const', ['mode'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [64, 272.0]
    rotation: 0
    state: disabled
- name: qtgui_edit_box_msg_0
  id: qtgui_edit_box_msg
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    gui_hint: ''
    is_pair: 'False'
    is_static: 'False'
    key: '1'
    label: 'Messege to sent:'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: string
    value: ''
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [64, 512.0]
    rotation: 180
    state: enabled
- name: qtgui_time_sink_x_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'False'
    grid: 'False'
    gui_hint: ''
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '"2"'
    nconnections: '1'
    size: '1024'
    srate: '10000000'
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_NORM
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: float
    update_time: '0.010'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [744, 416.0]
    rotation: 0
    state: enabled
- name: qtgui_time_sink_x_0_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '"Witout"'
    nconnections: '2'
    size: 1024 * 10
    srate: '10000000'
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_NORM
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: float
    update_time: '0.010'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1232, 152.0]
    rotation: 0
    state: enabled

connections:
- [blocks_char_to_float_0_0_0, '0', qtgui_time_sink_x_0, '0']
- [blocks_char_to_float_0_0_0_0, '0', epy_block_0, '0']
- [blocks_char_to_float_0_0_0_0, '0', qtgui_time_sink_x_0_0, '0']
- [blocks_char_to_float_0_0_0_1, '0', epy_block_0, '1']
- [blocks_char_to_float_0_0_0_1, '0', qtgui_time_sink_x_0_0, '1']
- [blocks_pack_k_bits_bb_0, '0', blocks_char_to_float_0_0_0_0, '0']
- [blocks_pack_k_bits_bb_0_0, '0', blocks_char_to_float_0_0_0_1, '0']
- [blocks_stream_demux_0, '0', blocks_pack_k_bits_bb_0, '0']
- [blocks_stream_demux_0, '1', blocks_pack_k_bits_bb_0_0, '0']
- [blocks_stream_demux_0_0, '0', blocks_char_to_float_0_0_0_0, '0']
- [blocks_stream_demux_0_0, '1', blocks_char_to_float_0_0_0_1, '0']
- [blocks_unpack_k_bits_bb_0_0, '0', blocks_char_to_float_0_0_0, '0']
- [blocks_unpack_k_bits_bb_0_0, '0', blocks_stream_demux_0, '0']
- [blocks_unpack_k_bits_bb_0_0, '0', blocks_stream_demux_0_0, '0']
- [epy_block_0, '0', blocks_null_sink_0, '0']
- [epy_block_0, '1', blocks_null_sink_0_0, '0']
- [epy_block_1, '0', blocks_unpack_k_bits_bb_0_0, '0']
- [epy_block_1, clear_input, qtgui_edit_box_msg_0, val]
- [epy_block_1_0_0, '0', blocks_unpack_k_bits_bb_0_0, '0']
- [qtgui_edit_box_msg_0, msg, epy_block_1, msg_in]

metadata:
  file_format: 1
  grc_version: 3.10.8.0
