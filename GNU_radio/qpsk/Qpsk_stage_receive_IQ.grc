options:
  parameters:
    author: Barry Duggan
    catch_exceptions: 'True'
    category: Custom
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: qpsk_stage6
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: qpsk_stage6
    window_size: 2000,2000
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [16, 16.0]
    rotation: 0
    state: enabled

blocks:
- name: blocks_char_to_float_0
  id: blocks_char_to_float
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    scale: '1'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1232, 136.0]
    rotation: 0
    state: disabled
- name: blocks_float_to_char_0
  id: blocks_float_to_char
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    scale: '1'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [936, 152.0]
    rotation: 0
    state: disabled
- name: blocks_float_to_char_0_0
  id: blocks_float_to_char
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    scale: '1'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [936, 208.0]
    rotation: 0
    state: disabled
- name: blocks_multiply_const_vxx_0
  id: blocks_multiply_const_vxx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    const: '0.01'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [496, 200.0]
    rotation: 0
    state: true
- name: blocks_multiply_const_vxx_0_0
  id: blocks_multiply_const_vxx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    const: '0.01'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [496, 264.0]
    rotation: 0
    state: true
- name: blocks_null_source_0
  id: blocks_null_source
  parameters:
    affinity: ''
    alias: ''
    bus_structure_source: '[[0,],]'
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_outputs: '1'
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 208.0]
    rotation: 0
    state: true
- name: blocks_null_source_0_0
  id: blocks_null_source
  parameters:
    affinity: ''
    alias: ''
    bus_structure_source: '[[0,],]'
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_outputs: '1'
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 240.0]
    rotation: 0
    state: true
- name: blocks_null_source_0_0_0
  id: blocks_null_source
  parameters:
    affinity: ''
    alias: ''
    bus_structure_source: '[[0,],]'
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_outputs: '1'
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [720, 168.0]
    rotation: 0
    state: disabled
- name: blocks_null_source_0_1
  id: blocks_null_source
  parameters:
    affinity: ''
    alias: ''
    bus_structure_source: '[[0,],]'
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_outputs: '1'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [648, 80.0]
    rotation: 0
    state: disabled
- name: blocks_null_source_0_2
  id: blocks_null_source
  parameters:
    affinity: ''
    alias: ''
    bus_structure_source: '[[0,],]'
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_outputs: '1'
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [720, 136.0]
    rotation: 0
    state: disabled
- name: blocks_pack_k_bits_bb_0
  id: blocks_pack_k_bits_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    k: '8'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1152, 80.0]
    rotation: 0
    state: disabled
- name: blocks_stream_mux_0
  id: blocks_stream_mux
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    lengths: (1, 1)
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '2'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1096, 168.0]
    rotation: 0
    state: disabled
- name: epy_block_0_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport serial\nimport\
      \ serial.tools.list_ports\nimport time\n\nimport numpy as np\nfrom gnuradio\
      \ import gr\nimport pmt\n\nMAX_DAC_NUM = 500   # \u041C\u0430\u043A\u0441\u0438\
      \u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\
      \u0441\u0442\u0432\u043E \u0447\u0438\u0441\u0435\u043B, \u043A\u043E\u0442\u043E\
      \u0440\u043E\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u0437\
      \u0430\u043F\u0438\u0441\u0430\u043D\u043E \u0432 const_signal\nMAX_DAC_VAL\
      \ = 10.0  # \u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\
      \u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u043D\u0430 \u0432\u044B\
      \u0445\u043E\u0434\u0435 \u0426\u0410\u041F\nCHUNK_SIZE = 10     # \u041C\u0430\
      \u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u043A\u043E\u043B\
      \u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0447\u0438\u0441\u0435\u043B \u0432\
      \ \u043E\u0434\u043D\u043E\u0439 \u043A\u043E\u043C\u0430\u043D\u0434\u0435\n\
      USB_PACKET_SIZE = 32 # \u0431\u0430\u0439\u0442\n# USB_PACKET_SIZE = 256 # \u0431\
      \u0430\u0439\u0442              \u0414\u041B\u042F dac mode\n\n\nclass ADIBlock(gr.sync_block):\
      \  # other base classes are basic_block, decim_block, interp_block\n    \"\"\
      \"\n    Read data from serial port and forward it to output. \n    portNumber\
      \ is number, you can see in the name of your \n    serial port in device manager,\
      \ like COM16 or COM7 \n    \"\"\"\n\n    \n    def __init__(self, portNumber=7,\
      \ mode = 3): \n        \"\"\"arguments to this function show up as parameters\
      \ in GRC\"\"\"\n        self.portNumber = portNumber  # \u0421\u043E\u0445\u0440\
      \u0430\u043D\u044F\u0435\u043C \u043D\u043E\u043C\u0435\u0440 \u043F\u043E\u0440\
      \u0442\u0430\n        # portName = 'COM' + str(portNumber)                 \
      \ # Concatenate string and number\n        \n        gr.sync_block.__init__(\n\
      \            self,\n            name = 'Analog Digital Interface',   \n    \
      \        in_sig = [np.float32, np.float32],                # \u0412\u0445\u043E\
      \u0434\u044B\n            out_sig = [np.float32, np.float32]  # \u0412\u044B\
      \u0445\u043E\u0434\u044B\n        )\n\n        # \u0420\u0435\u0433\u0438\u0441\
      \u0442\u0440\u0430\u0446\u0438\u044F \u0438\u043C\u0435\u043D\u043E\u0432\u0430\
      \u043D\u043D\u044B\u0445 \u0432\u0445\u043E\u0434\u043D\u044B\u0445 \u0438 \u0432\
      \u044B\u0445\u043E\u0434\u043D\u044B\u0445 \u043F\u043E\u0440\u0442\u043E\u0432\
      \n        self.message_port_register_in(pmt.intern('set_const_signal'))\n  \
      \      self.set_msg_handler(pmt.intern('set_const_signal'), self.handle_msg)\n\
      \        # self.message_port_register_out(pmt.intern('msg_out'))\n\n       \
      \  # \u0418\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0430\u0446\u0438\
      \u044F \u043F\u0435\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0445 \u0434\u043B\
      \u044F COM \u043F\u043E\u0440\u0442\u0430\n        self.port = None\n      \
      \  self.port_name = None\n        self.baudrate = 2000000  # \u0417\u0434\u0435\
      \u0441\u044C \u0437\u0430\u0445\u0430\u0440\u0434\u043A\u043E\u0436\u0435\u043D\
      \ baudrate\n        self.mode = mode\n        self.remaining_data = bytearray(USB_PACKET_SIZE\
      \ + 1)  # \u0411\u0443\u0444\u0435\u0440 \u0434\u043B\u044F \u043E\u0441\u0442\
      \u0430\u0432\u0448\u0438\u0445\u0441\u044F \u0434\u0430\u043D\u043D\u044B\u0445\
      \     0\u043E\u0439 \u0431\u0430\u0439\u0442 - \u0444\u043B\u0430\u0433 (0 -\
      \ \u0432 \u043C\u0430\u0441\u0441\u0438\u0432\u0435 \u043D\u0435\u0442 \u043F\
      \u043E\u043B\u0435\u0437\u043D\u044B\u0445 \u0434\u0430\u043D\u043D\u044B\u0445\
      , 1 - \u043D\u0430\u0434\u043E \u0447\u0438\u0442\u0430\u0442\u044C)\n     \
      \   \n    def open_port(self):\n        \"\"\"\u041E\u0442\u043A\u0440\u044B\
      \u0432\u0430\u0435\u0442 COM \u043F\u043E\u0440\u0442, \u0435\u0441\u043B\u0438\
      \ \u043E\u043D \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442\
      \ \u0438 \u043D\u0435 \u0437\u0430\u043D\u044F\u0442.\"\"\"\n        baudrate\
      \ = 2000000\n        portName = 'COM' + str(self.portNumber)\n\n        # \u041F\
      \u043E\u043B\u0443\u0447\u0430\u0435\u043C \u0441\u043F\u0438\u0441\u043E\u043A\
      \ \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u0445 COM \u043F\u043E\u0440\
      \u0442\u043E\u0432\n        available_ports = [port.device for port in serial.tools.list_ports.comports()]\n\
      \n        if portName not in available_ports:\n            print(f\"\u041E\u0448\
      \u0438\u0431\u043A\u0430: \u041F\u043E\u0440\u0442 {portName} \u043D\u0435 \u043D\
      \u0430\u0439\u0434\u0435\u043D.\")\n            return\n        \n        try:\n\
      \            # \u041F\u044B\u0442\u0430\u0435\u043C\u0441\u044F \u043E\u0442\
      \u043A\u0440\u044B\u0442\u044C \u043F\u043E\u0440\u0442\n            self.port\
      \ = serial.Serial(portName, baudrate, timeout=3.0)\n            # \u0415\u0441\
      \u043B\u0438 \u043F\u043E\u0440\u0442 \u0443\u0436\u0435 \u0431\u044B\u043B\
      \ \u043E\u0442\u043A\u0440\u044B\u0442, \u0437\u0430\u043A\u0440\u044B\u0432\
      \u0430\u0435\u043C \u0435\u0433\u043E \u0438 \u043E\u0442\u043A\u0440\u044B\u0432\
      \u0430\u0435\u043C \u0437\u0430\u043D\u043E\u0432\u043E\n            if self.port.is_open:\n\
      \                self.port.close()\n                self.port.open()\n     \
      \       else:\n                self.port.open()\n            print(f\"\u041F\
      \u043E\u0440\u0442 {portName} \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043E\
      \u0442\u043A\u0440\u044B\u0442.\")\n        except serial.SerialException as\
      \ e:\n            # \u0415\u0441\u043B\u0438 \u043D\u0435 \u0443\u0434\u0430\
      \u043B\u043E\u0441\u044C \u043E\u0442\u043A\u0440\u044B\u0442\u044C \u043F\u043E\
      \u0440\u0442 (\u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043E\u043D\
      \ \u0437\u0430\u043D\u044F\u0442), \u0432\u044B\u0432\u043E\u0434\u0438\u043C\
      \ \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0435 \u043E\u0431 \u043E\
      \u0448\u0438\u0431\u043A\u0435\n            print(f\"\u041E\u0448\u0438\u0431\
      \u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043A\u0440\u044B\u0442\u0438\u0438\
      \ \u043F\u043E\u0440\u0442\u0430 {portName}: {e}\")\n            self.port =\
      \ None\n\n\n    def set_mode(self, mode_setting):\n        if mode_setting <\
      \ 4:\n            command = \"mode \" + str(mode_setting)  \n        else:\n\
      \            command = \"dac_mode\"\n        try:\n            self.port.write(command.encode('ascii'))\n\
      \            print(f\"\u041E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\
      \u043E: {command}\")\n            time.sleep(0.01)\n        except serial.SerialException\
      \ as e:\n            print(f\"\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\
      \u0438 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0435 \u0434\u0430\u043D\u043D\
      \u044B\u0445: {e}\")\n\n\n    def handle_msg(self, msg):\n        \"\"\"\u041E\
      \u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u0432\u0445\u043E\u0434\u043D\
      \u044B\u0445 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0439.\"\"\"\n\
      \        # \u041F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\
      \u043D\u0438\u0435 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u044F \u0432\
      \ \u0441\u043F\u0438\u0441\u043E\u043A \u0447\u0438\u0441\u0435\u043B \u0441\
      \ \u043F\u043B\u0430\u0432\u0430\u044E\u0449\u0435\u0439 \u0437\u0430\u043F\u044F\
      \u0442\u043E\u0439\n        numbers = pmt.to_python(msg)        # \u041F\u0440\
      \u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D\u0438\u0435 \u0432\
      \ \u0441\u0442\u0440\u043E\u043A\u0443\n        numbers = [float(x) for x in\
      \ numbers.split()]\n        print(\"AAAAAAAAAAAAAAAAAAAAAA\")\n        # print(numbers[30])\n\
      \n        # if not isinstance(numbers, list):\n        #     print(\"\u041E\u0448\
      \u0438\u0431\u043A\u0430: \u041E\u0436\u0438\u0434\u0430\u043B\u0441\u044F \u0441\
      \u043F\u0438\u0441\u043E\u043A \u0447\u0438\u0441\u0435\u043B.\")\n        #\
      \     return\n\n        if len(numbers) > MAX_DAC_NUM:\n            print(f\"\
      \u041E\u0448\u0438\u0431\u043A\u0430: \u0421\u043B\u0438\u0448\u043A\u043E\u043C\
      \ \u043C\u043D\u043E\u0433\u043E \u0447\u0438\u0441\u0435\u043B. \u041C\u0430\
      \u043A\u0441\u0438\u043C\u0443\u043C {MAX_DAC_NUM}.\")\n            return\n\
      \n        if any(val > MAX_DAC_VAL for val in numbers):\n            print(f\"\
      \u041E\u0448\u0438\u0431\u043A\u0430: \u0417\u043D\u0430\u0447\u0435\u043D\u0438\
      \u044F \u043D\u0435 \u043C\u043E\u0433\u0443\u0442 \u043F\u0440\u0435\u0432\u044B\
      \u0448\u0430\u0442\u044C {MAX_DAC_VAL}.\")\n            return\n\n        #\
      \ \u041E\u0442\u043A\u0440\u044B\u0442\u0438\u0435 \u043F\u043E\u0440\u0442\u0430\
      , \u0435\u0441\u043B\u0438 \u0435\u0449\u0435 \u043D\u0435 \u043E\u0442\u043A\
      \u0440\u044B\u0442\n        if self.port is None:\n            self.open_port()\n\
      \n        if self.port is not None and self.port.is_open:\n            # \u0420\
      \u0430\u0437\u0434\u0435\u043B\u0435\u043D\u0438\u0435 \u0434\u0430\u043D\u043D\
      \u044B\u0445 \u043D\u0430 \u043A\u0443\u0441\u043A\u0438 \u043F\u043E 10 \u0447\
      \u0438\u0441\u0435\u043B \u0438 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0430\
      \n            for i in range(0, len(numbers), CHUNK_SIZE):\n               \
      \ chunk = numbers[i:i + CHUNK_SIZE]\n                command = \"set \" + \"\
      \ \".join(map(str, chunk))\n                if i + CHUNK_SIZE >= len(numbers):\n\
      \                    command += \" !\"\n                \n                try:\n\
      \                    self.port.write(command.encode('ascii'))\n            \
      \        print(f\"\u041E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E\
      : {command}\")\n                    time.sleep(0.01)\n                except\
      \ serial.SerialException as e:\n                    print(f\"\u041E\u0448\u0438\
      \u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\
      \u0435 \u0434\u0430\u043D\u043D\u044B\u0445: {e}\")\n\n\n            \n    def\
      \ work(self, input_items, output_items):\n\n        if self.port is None:\n\
      \            # \u0415\u0441\u043B\u0438 \u043F\u043E\u0440\u0442 \u043D\u0435\
      \ \u043E\u0442\u043A\u0440\u044B\u0442, \u043F\u043E\u043F\u044B\u0442\u0430\
      \u0442\u044C\u0441\u044F \u043E\u0442\u043A\u0440\u044B\u0442\u044C \u0435\u0433\
      \u043E\n            self.open_port()\n            self.set_mode(self.mode)\n\
      \n        # \u0421\u043B\u0443\u0447\u0430\u0439 \u043E\u0431\u044B\u0447\u043D\
      \u043E\u0439 \u0440\u0430\u0431\u043E\u0442\u044B (\u0423\u043F\u043E\u0440\
      \ \u043D\u0430 \u0410\u0426\u041F)\n        if self.mode < 4:\n            n\
      \ = 0\n            chunk_size = USB_PACKET_SIZE\n            output_len = len(output_items[0])\n\
      \            # print (output_len)\n            data = bytearray(chunk_size)\
      \  # \u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u043C\u0430\u0441\u0441\
      \u0438\u0432\u0430 \u0431\u0430\u0439\u0442\u043E\u0432 \u0434\u043B\u044F \u0447\
      \u0442\u0435\u043D\u0438\u044F \u0434\u0430\u043D\u043D\u044B\u0445\n      \
      \      n_increment = (USB_PACKET_SIZE if self.mode < 3 else (USB_PACKET_SIZE\
      \ // 2))\n\n                \n            while n < (output_len - n_increment):\n\
      \                chunk_size = USB_PACKET_SIZE\n            \n              \
      \  # \u041E\u0431\u044A\u0435\u0434\u0438\u043D\u044F\u0435\u043C \u043E\u0441\
      \u0442\u0430\u0442\u043E\u0447\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\
      \u0435 \u0438\u0437 \u043F\u0440\u0435\u0434\u044B\u0434\u0443\u0449\u0435\u0439\
      \ \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0438 \u0441 \u043D\u043E\u0432\
      \u044B\u043C\u0438\n                if self.remaining_data[0] == 1:\n      \
      \              # data = bytearray(chunk_size)  # \u0421\u043E\u0437\u0434\u0430\
      \u043D\u0438\u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u0430 \u0431\u0430\u0439\
      \u0442\u043E\u0432 \u0434\u043B\u044F \u0447\u0442\u0435\u043D\u0438\u044F \u0434\
      \u0430\u043D\u043D\u044B\u0445\n                    chunk_size = len(self.remaining_data)\
      \ - 1\n                    data = bytearray(chunk_size)\n                  \
      \  data = self.remaining_data[1:]       # \u0421\u043E\u0445\u0440\u0430\u043D\
      \u0438\u0442\u044C \u0434\u0430\u043D\u043D\u044B\u0435 \n                 \
      \   # print (data)\n                    # data[-1:] = b'\\x00'\n           \
      \         # print(len(self.remaining_data))\n                    # print(data)\n\
      \                    # print(\"YES\")\n                    # while True:\n \
      \                   #     pass\n                    self.remaining_data = bytearray(USB_PACKET_SIZE\
      \ + 1)  # \u041E\u0447\u0438\u0449\u0430\u0435\u043C \u0431\u0443\u0444\u0435\
      \u0440\n                else:\n                    data = bytearray(chunk_size)\
      \  # \u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u043C\u0430\u0441\u0441\
      \u0438\u0432\u0430 \u0431\u0430\u0439\u0442\u043E\u0432 \u0434\u043B\u044F \u0447\
      \u0442\u0435\u043D\u0438\u044F \u0434\u0430\u043D\u043D\u044B\u0445\n      \
      \              self.port.readinto(data)  # \u0421\u0447\u0438\u0442\u044B\u0432\
      \u0430\u043D\u0438\u0435 \u0434\u0430\u043D\u043D\u044B\u0445 \u043D\u0435\u043F\
      \u043E\u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0435\u043D\u043D\u043E \u0432\
      \ \u043C\u0430\u0441\u0441\u0438\u0432 \u0431\u0430\u0439\u0442\u043E\u0432\n\
      \n                if self.mode < 2:  # mode can be 0 or 1, \u043E\u0431\u0430\
      \ \u0432\u043A\u043B\u044E\u0447\u0430\u044E\u0442 \u0442\u043E\u043B\u044C\u043A\
      \u043E 1 \u043A\u0430\u043D\u0430\u043B \u0410\u0426\u041F\n               \
      \     output_items[0][n:n + chunk_size] = data[:chunk_size]\n              \
      \      n += chunk_size\n                else:\n                    # TEST 8\
      \ bit\n                    output_items[0][n:n + chunk_size // 2] = data[0::2]\n\
      \                    output_items[1][n:n + chunk_size // 2] = data[1::2]\n \
      \                   # output_items[1][n] = b'\\x30'\n                    n +=\
      \ chunk_size // 2\n\n                    # TESST\n\n            # \u041E\u0431\
      \u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0441\u0442\u0430\u0432\u0448\
      \u0435\u0433\u043E\u0441\u044F \u043C\u0435\u0441\u0442\u0430 \u0432 output_items\n\
      \            if n < output_len:\n                self.port.readinto(data)  #\
      \ \u0421\u0447\u0438\u0442\u044B\u0432\u0430\u0435\u043C \u0434\u0430\u043D\u043D\
      \u044B\u0435 \u0432 \u043C\u0430\u0441\u0441\u0438\u0432 \u0431\u0430\u0439\u0442\
      \u043E\u0432\n                if self.mode < 2:  # mode can be 0 \u0438\u043B\
      \u0438 1, \u043E\u0431\u0430 \u0432\u043A\u043B\u044E\u0447\u0430\u044E\u0442\
      \ \u0442\u043E\u043B\u044C\u043A\u043E 1 \u043A\u0430\u043D\u0430\u043B \u0410\
      \u0426\u041F\n                    bytes_to_copy = min(chunk_size, output_len\
      \ - n)\n                    output_items[0][n:n + bytes_to_copy] = data[:bytes_to_copy]\n\
      \                    n += bytes_to_copy\n                    self.remaining_data\
      \ = data[bytes_to_copy:]  # \u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0435\
      \u043C \u043E\u0441\u0442\u0430\u0432\u0448\u0438\u0435\u0441\u044F \u0434\u0430\
      \u043D\u043D\u044B\u0435\n                else:\n                    i = 0\n\
      \                    # print(n)\n                    while n < output_len and\
      \ i < chunk_size:\n                        output_items[0][n] = data[i] \n \
      \                       output_items[1][n] = data[i + 1]\n                 \
      \       n += 1\n                        i += 2\n                    # output_items[1][n-1]\
      \ = 300\n                    self.remaining_data = bytearray(USB_PACKET_SIZE\
      \ - i + 1)\n                    self.remaining_data[1:] = data[i:]  # \u0421\
      \u043E\u0445\u0440\u0430\u043D\u044F\u0435\u043C \u043E\u0441\u0442\u0430\u0432\
      \u0448\u0438\u0435\u0441\u044F \u0434\u0430\u043D\u043D\u044B\u0435\n      \
      \              self.remaining_data[0] = (0 if (USB_PACKET_SIZE - i) == 0 else\
      \ 1)  # \u0424\u043B\u0430\u0433 \u0437\u0430\u043F\u0440\u043E\u0441\u0430\
      \ \u0447\u0442\u0435\u043D\u0438\u044F\n                    # print(n)\n   \
      \                 # print(self.remaining_data)\n\n            return len(output_items[0])\
      \  # \u0412\u043E\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043C \u043A\u043E\
      \u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043E\u0431\u0440\u0430\u0431\
      \u043E\u0442\u0430\u043D\u043D\u044B\u0445 \u044D\u043B\u0435\u043C\u0435\u043D\
      \u0442\u043E\u0432\n\n\n\n\n                # \u0421\u043B\u0443\u0447\u0430\
      \u0439, \u043A\u043E\u0433\u0434\u0430 mode >= 4 (dac_mode) - \u0443\u043F\u043E\
      \u0440 \u043D\u0430 \u0426\u0410\u041F, \u0410\u0426\u041F \u043E\u0442\u043A\
      \u043B\u044E\u0447\u0435\u043D\n        # \u0421\u043B\u0443\u0447\u0430\u0439\
      , \u043A\u043E\u0433\u0434\u0430 mode >= 4 (dac_mode) - \u0443\u043F\u043E\u0440\
      \ \u043D\u0430 \u0426\u0410\u041F, \u0410\u0426\u041F \u043E\u0442\u043A\u043B\
      \u044E\u0447\u0435\u043D\n        else:\n            data = bytearray(USB_PACKET_SIZE\
      \ )  # \u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u043C\u0430\u0441\u0441\
      \u0438\u0432\u0430 \u0431\u0430\u0439\u0442\u043E\u0432 \u0434\u043B\u044F \u0447\
      \u0442\u0435\u043D\u0438\u044F \u0434\u0430\u043D\u043D\u044B\u0445\n      \
      \      n = 0\n            remaining_len = 0\n            input_len = min(len(input_items[0]),\
      \ len(input_items[1]))  # \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\
      \u043C \u043C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\u043D\u0443\u044E \u0434\
      \u043B\u0438\u043D\u0443 \u0434\u043B\u044F \u0438\u0437\u0431\u0435\u0436\u0430\
      \u043D\u0438\u044F \u0432\u044B\u0445\u043E\u0434\u0430 \u0437\u0430 \u0433\u0440\
      \u0430\u043D\u0438\u0446\u044B\n\n            # \u0415\u0441\u043B\u0438 \u0435\
      \u0441\u0442\u044C remaining_data, \u043E\u0431\u044A\u0435\u0434\u0438\u043D\
      \u044F\u0435\u043C \u0435\u0433\u043E \u0441 \u0442\u0435\u043A\u0443\u0449\u0438\
      \u043C\u0438 \u0434\u0430\u043D\u043D\u044B\u043C\u0438\n            if self.remaining_data:\n\
      \                remaining_len = len(self.remaining_data)\n                #\
      \ \u0423\u0432\u0435\u043B\u0438\u0447\u0438\u0432\u0430\u0435\u043C \u0440\u0430\
      \u0437\u043C\u0435\u0440 \u0431\u0443\u0444\u0435\u0440\u0430, \u0434\u043E\u0431\
      \u0430\u0432\u043B\u044F\u044F \u0434\u043B\u0438\u043D\u0443 remaining_data\n\
      \                data = self.remaining_data + data[:USB_PACKET_SIZE  - remaining_len]\
      \  # \u041E\u0433\u0440\u0430\u043D\u0438\u0447\u0438\u0432\u0430\u0435\u043C\
      \ data \u043F\u043E \u0440\u0430\u0437\u043C\u0435\u0440\u0443\n           \
      \     self.remaining_data = bytearray()  # \u041E\u0447\u0438\u0449\u0430\u0435\
      \u043C \u0431\u0443\u0444\u0435\u0440 \u043F\u043E\u0441\u043B\u0435 \u043E\u0431\
      \u044A\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u044F\n\n            while\
      \ n < input_len:\n                i = remaining_len  # \u0421\u0431\u0440\u0430\
      \u0441\u044B\u0432\u0430\u0435\u043C \u0438\u043D\u0434\u0435\u043A\u0441 \u0434\
      \u043B\u044F data\n\n                while i < (USB_PACKET_SIZE ) and n < input_len:\
      \  # \u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C \u0438 n\n     \
      \               value1 = int((input_items[0][n] + 1) * 4095 / 2) & 0xFFFF  #\
      \ \u041F\u0440\u0438\u0432\u0435\u0434\u0435\u043D\u0438\u0435 \u043A \u0446\
      \u0435\u043B\u043E\u043C\u0443 \u0447\u0438\u0441\u043B\u0443 \u0438 \u043E\u0433\
      \u0440\u0430\u043D\u0438\u0447\u0435\u043D\u0438\u0435 \u0434\u043E 16 \u0431\
      \u0438\u0442\n                    data[i] = value1 & 0xFF  # \u041C\u043B\u0430\
      \u0434\u0448\u0438\u0439 \u0431\u0430\u0439\u0442\n                    data[i\
      \ + 1] = (value1 >> 8) & 0xFF  # \u0421\u0442\u0430\u0440\u0448\u0438\u0439\
      \ \u0431\u0430\u0439\u0442\n                    i += 2\n                   \
      \ value2 = int((input_items[1][n] + 1) * 4095 / 2) & 0xFFFF  # \u041F\u0440\u0438\
      \u0432\u0435\u0434\u0435\u043D\u0438\u0435 \u043A \u0446\u0435\u043B\u043E\u043C\
      \u0443 \u0447\u0438\u0441\u043B\u0443 \u0438 \u043E\u0433\u0440\u0430\u043D\u0438\
      \u0447\u0435\u043D\u0438\u0435 \u0434\u043E 16 \u0431\u0438\u0442\n        \
      \            data[i] = value2 & 0xFF  # \u041C\u043B\u0430\u0434\u0448\u0438\
      \u0439 \u0431\u0430\u0439\u0442\n                    data[i + 1] = (value2 >>\
      \ 8) & 0xFF  # \u0421\u0442\u0430\u0440\u0448\u0438\u0439 \u0431\u0430\u0439\
      \u0442\n                    i += 2\n                    n += 1\n\n         \
      \       # \u041E\u0442\u043F\u0440\u0430\u0432\u043B\u044F\u0435\u043C \u0441\
      \u043E\u0431\u0440\u0430\u043D\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\
      \u0435 \u0432 \u043F\u043E\u0440\u0442\n                self.port.write(data)\
      \  # \u041E\u0442\u043F\u0440\u0430\u0432\u043B\u044F\u0435\u043C \u0442\u043E\
      \u043B\u044C\u043A\u043E \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u043D\
      \u0443\u044E \u0447\u0430\u0441\u0442\u044C\n                remaining_len =\
      \ 0\n                data = bytearray(USB_PACKET_SIZE )\n\n            # \u041E\
      \u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0441\u0442\u0430\u0432\
      \u0448\u0438\u0445\u0441\u044F \u0434\u0430\u043D\u043D\u044B\u0445\n      \
      \      if n < input_len:\n                remaining_data = bytearray()\n\n \
      \               while n < input_len and i < USB_PACKET_SIZE :\n            \
      \        value1 = int((input_items[0][n] + 1) * 4095 / 2) & 0xFFFF\n       \
      \             remaining_data.append(value1 & 0xFF)\n                    remaining_data.append((value1\
      \ >> 8) & 0xFF)\n                    i += 2\n                    value2 = int((input_items[1][n]\
      \ + 1) * 4095 / 2) & 0xFFFF\n                    remaining_data.append(value2\
      \ & 0xFF)\n                    remaining_data.append((value2 >> 8) & 0xFF)\n\
      \                    i += 2\n                    n += 1\n\n                #\
      \ \u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0435\u043C \u043E\u0441\u0442\u0430\
      \u0442\u043E\u0447\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435 \u0434\
      \u043B\u044F \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E \u0432\
      \u044B\u0437\u043E\u0432\u0430\n                self.remaining_data = remaining_data\n\
      \n            return len(input_items[0])\n\n"
    affinity: ''
    alias: ''
    comment: "mode = 0,    // 1\u044B\u0439 \u043A\u0430\u043D\u0430\u043B \u0410\u0426\
      \u041F, 1\u044B\u0439 \u043A\u0430\u043D\u0430\u043B \u0426\u0410\u041F \nmode\
      \  = 1,    // 1\u044B\u0439 \u043A\u0430\u043D\u0430\u043B \u0410\u0426\u041F\
      , 2 \u043A\u0430\u043D\u0430\u043B\u0430 \u0426\u0410\u041F    \nmode  = 2,\
      \    // 2 \u043A\u0430\u043D\u0430\u043B\u0430 \u0410\u0426\u041F, 1\u044B\u0439\
      \ \u043A\u0430\u043D\u0430\u043B\u0430 \u0426\u0410\u041F  \nmode = 3,    //\
      \ 2 \u043A\u0430\u043D\u0430\u043B\u0430 \u0410\u0426\u041F, 2 \u043A\u0430\u043D\
      \u0430\u043B\u0430 \u0426\u0410\u041F\nmode >= 4  // dac_mode"
    maxoutbuf: '0'
    minoutbuf: '0'
    mode: '3'
    portNumber: '10'
  states:
    _io_cache: ('Analog Digital Interface', 'ADIBlock', [('portNumber', '7'), ('mode',
      '3')], [('0', 'float', 1), ('1', 'float', 1), ('set_const_signal', 'message',
      1)], [('0', 'float', 1), ('1', 'float', 1)], '\n    Read data from serial port
      and forward it to output. \n    portNumber is number, you can see in the name
      of your \n    serial port in device manager, like COM16 or COM7 \n    ', ['mode',
      'portNumber'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [248, 208.0]
    rotation: 0
    state: enabled
- name: epy_block_1
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\n\n\nclass blk(gr.sync_block):  # other base classes\
      \ are basic_block, decim_block, interp_block\n    \"\"\"Embedded Python Block\
      \ example - a simple multiply const\"\"\"\n\n    def __init__(self, example_param=1.0):\
      \  # only default arguments here\n        \"\"\"arguments to this function show\
      \ up as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n         \
      \   self,\n            name='Test string decoder',   # will show up in GRC\n\
      \            in_sig=[np.byte],\n            out_sig=[]\n        )\n        #\
      \ if an attribute with the same name as a parameter is found,\n        # a callback\
      \ is registered (properties work, too).\n        self.example_param = example_param\n\
      \n    def work(self, input_items, output_items):\n        i = 0\n        messege\
      \ = \"\"\n        input_len = len(input_items[0])\n        while(i < (input_len)):\n\
      \            messege += str(input_items[0][i])\n            if(input_items[0][i]\
      \ == '\\n'):\n                print(messege)\n                messege = \"\"\
      \n            i += 1\n        return len(input_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    example_param: '1.0'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Test string decoder', 'blk', [('example_param', '1.0')], [('0', 'byte',
      1)], [], 'Embedded Python Block example - a simple multiply const', ['example_param'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [808, 72.0]
    rotation: 0
    state: disabled
- name: epy_block_1_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\n\n\nclass blk(gr.sync_block):  # other base classes\
      \ are basic_block, decim_block, interp_block\n    \"\"\"Embedded Python Block\
      \ example - a simple multiply const\"\"\"\n\n    def __init__(self, example_param=1.0):\
      \  # only default arguments here\n        \"\"\"arguments to this function show\
      \ up as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n         \
      \   self,\n            name='Decode IQ QPSK',   # will show up in GRC\n    \
      \        in_sig=[np.float32, np.float32],\n            out_sig=[np.float32,\
      \ np.float32]\n        )\n        # if an attribute with the same name as a\
      \ parameter is found,\n        # a callback is registered (properties work,\
      \ too).\n        self.example_param = example_param\n\n    def work(self, input_items,\
      \ output_items):\n        # 1 - \u043D\u0430\u0439\u0442\u0438 \u043F\u0435\u0440\
      \u0435\u0445\u043E\u0434 1 -> 0\n        output_items[0].fill(0)\n        output_items[1].fill(0)\n\
      \        i = 0\n        j = 0\n        output_len = len(output_items[0])\n \
      \       input_len = len(input_items[0])\n        # while (i < (input_len - 1))\
      \ and (abs(input_items[0][i] - input_items[0][i+1]) < 0.3) and (abs(input_items[1][i]\
      \ - input_items[1][i+1]) < 0.3):\n        #     i += 1\n        # while (i <\
      \ (input_len - 1)):\n        #     while (i < (input_len - 1)) and (abs(input_items[0][i]\
      \ - input_items[0][i+1]) < 0.3) and (abs(input_items[1][i] - input_items[1][i+1])\
      \ < 0.3):\n        #         output_items[0][i] = input_items[0][i]\n      \
      \  #         output_items[1][i] = input_items[1][i]\n        #         i +=\
      \ 1   \n        #     output_items[1][i] = 3\n\n        # Works but only for\
      \ 0x10\n        # while (i < (input_len - 7)):\n        #     # \u041A\u043E\
      \u043F\u0438\u0440\u0443\u0435\u043C \u0442\u0435\u043A\u0443\u0449\u0438\u0435\
      \ \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B \u0432 output_items \u0434\
      \u043E \u0442\u0435\u0445 \u043F\u043E\u0440, \u043F\u043E\u043A\u0430 \u0443\
      \u0441\u043B\u043E\u0432\u0438\u0435 \u0432\u044B\u043F\u043E\u043B\u043D\u044F\
      \u0435\u0442\u0441\u044F\n        #     diff_0 = abs(input_items[0][i] - input_items[0][i+1])\n\
      \        #     diff_1 = abs(input_items[1][i] - input_items[1][i+1])\n     \
      \   #     # \u0418\u0449\u0435\u043C \u043E\u043F\u043E\u0440\u0443 \u0434\u043B\
      \u044F \u043E\u0442\u0441\u0447\u0435\u0442\u043E\u0432\n        #     if diff_0\
      \ < 0.3 and diff_1 < 0.3:\n        #         pass\n        #     else:\n   \
      \     #         output_items[1][j] = input_items[1][i+2]    # \u041C\u0430\u0440\
      \u043A\u0438\u0440\u043E\u0432\u043A\u0430 \u0441\u0447\u0438\u0442\u044B\u0432\
      \u0430\u043D\u0438\u044F 1\n        #         output_items[1][j+1] = input_items[1][i+6]\
      \    # \u041C\u0430\u0440\u043A\u0438\u0440\u043E\u0432\u043A\u0430 \u0441\u0447\
      \u0438\u0442\u044B\u0432\u0430\u043D\u0438\u044F 1\n        #         # \u0412\
      \u0442\u043E\u0440\u043E\u0439 \u043A\u0430\u043D\u0430\u043B\n        #   \
      \      output_items[0][j] = input_items[0][i+2]    # \u041C\u0430\u0440\u043A\
      \u0438\u0440\u043E\u0432\u043A\u0430 \u0441\u0447\u0438\u0442\u044B\u0432\u0430\
      \u043D\u0438\u044F 1\n        #         output_items[0][j+1] = input_items[0][i+6]\
      \    # \u041C\u0430\u0440\u043A\u0438\u0440\u043E\u0432\u043A\u0430 \u0441\u0447\
      \u0438\u0442\u044B\u0432\u0430\u043D\u0438\u044F 1\n        #         i += 6\n\
      \        #         j += 2\n\n        #     i += 1\n\n\n\n        # \u041F\u0430\
      \u0440\u0430\u043C\u0435\u0442\u0440 N \u2014 \u043A\u043E\u043B\u0438\u0447\
      \u0435\u0441\u0442\u0432\u043E \u0432\u044B\u0431\u043E\u0440\u043E\u043A, \u043A\
      \u043E\u0442\u043E\u0440\u044B\u0435 \u043D\u0443\u0436\u043D\u043E \u0441\u0434\
      \u0435\u043B\u0430\u0442\u044C \u043F\u043E\u0441\u043B\u0435 \u043D\u0430\u0445\
      \u043E\u0436\u0434\u0435\u043D\u0438\u044F \u043E\u043F\u043E\u0440\u044B\n\
      \        N = 1  # \u041C\u043E\u0436\u043D\u043E \u0438\u0437\u043C\u0435\u043D\
      \u0438\u0442\u044C \u043D\u0430 \u043D\u0443\u0436\u043D\u043E\u0435 \u0437\u043D\
      \u0430\u0447\u0435\u043D\u0438\u0435\n        step = 4  # \u0428\u0430\u0433\
      \ \u0434\u043B\u044F \u0432\u044B\u0431\u043E\u0440\u043A\u0438 (\u043A\u0430\
      \u0436\u0434\u044B\u0439 \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u044B\u0439\
      \ \u044D\u043B\u0435\u043C\u0435\u043D\u0442)\n        start_index = 0   # \u0418\
      \u043D\u0434\u0435\u043A\u0441 \u043E\u043F\u043E\u0440\u043D\u043E\u0433\u043E\
      \ \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\n        opora_found = False\
      \  # \u0424\u043B\u0430\u0433, \u0443\u043A\u0430\u0437\u044B\u0432\u0430\u044E\
      \u0449\u0438\u0439, \u043D\u0430\u0439\u0434\u0435\u043D\u0430 \u043B\u0438\
      \ \u043E\u043F\u043E\u0440\u0430\n\n        while i < (input_len - 7):\n   \
      \         if not opora_found:\n                # \u0415\u0441\u043B\u0438 \u043E\
      \u043F\u043E\u0440\u0430 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u0430\
      , \u043F\u0440\u043E\u0434\u043E\u043B\u0436\u0430\u0435\u043C \u0431\u0440\u0430\
      \u0442\u044C \u043A\u0430\u0436\u0434\u044B\u0439 \u0447\u0435\u0442\u0432\u0435\
      \u0440\u0442\u044B\u0439 \u044D\u043B\u0435\u043C\u0435\u043D\u0442\n      \
      \          if (i - start_index + 1) % step == 0:\n                    output_items[0][j]\
      \ = (1 if input_items[0][i] > 0.5  else 0)\n                    output_items[1][j]\
      \ = (1 if input_items[1][i] > 0.5  else 0)\n                    j += 1\n\n \
      \               # \u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C, \u043D\
      \u0430\u0448\u043B\u0438 \u043B\u0438 \u043C\u044B \u043E\u043F\u043E\u0440\u0443\
      \n                diff_0 = abs(input_items[0][i] - input_items[0][i+1])\n  \
      \              diff_1 = abs(input_items[1][i] - input_items[1][i+1])\n     \
      \           \n                if diff_0 >= 0.3 or diff_1 >= 0.3:\n         \
      \           opora_found = True  # \u041E\u043F\u043E\u0440\u0430 \u043D\u0430\
      \u0439\u0434\u0435\u043D\u0430, \u043F\u0435\u0440\u0435\u043A\u043B\u044E\u0447\
      \u0430\u0435\u043C\u0441\u044F \u043D\u0430 \u0432\u044B\u0431\u043E\u0440\u043A\
      \u0438 \u0441 i+2\n                    i += 1  # \u0421\u0434\u0432\u0438\u0433\
      \ \u043D\u0430 i+2 \u0434\u043B\u044F \u043D\u0430\u0447\u0430\u043B\u0430 \u043D\
      \u043E\u0432\u043E\u0439 \u0432\u044B\u0431\u043E\u0440\u043A\u0438\n      \
      \              start_index = i     # \u041D\u043E\u0432\u044B\u0439 \u0438\u043D\
      \u0434\u0435\u043A\u0441 \u043E\u043F\u043E\u0440\u043D\u043E\u0433\u043E \u044D\
      \u043B\u0435\u043C\u0435\u043D\u0442\u0430\n            else:\n            \
      \    # \u041E\u043F\u043E\u0440\u0430 \u043D\u0430\u0439\u0434\u0435\u043D\u0430\
      , \u0432\u044B\u043F\u043E\u043B\u043D\u044F\u0435\u043C N \u0432\u044B\u0431\
      \u043E\u0440\u043E\u043A \u0441 \u0448\u0430\u0433\u043E\u043C 4, \u043D\u0430\
      \u0447\u0438\u043D\u0430\u044F \u0441 i+2\n                for n in range(N):\n\
      \                    idx = i + n * step  # \u041F\u0435\u0440\u0432\u0430\u044F\
      \ \u0432\u044B\u0431\u043E\u0440\u043A\u0430 \u043D\u0430 i, \u043E\u0441\u0442\
      \u0430\u043B\u044C\u043D\u044B\u0435 \u0441 \u0448\u0430\u0433\u043E\u043C 4\n\
      \                    if idx < input_len:\n                        output_items[0][j]\
      \ = (1 if input_items[0][idx] > 0.5  else 0)\n                        output_items[1][j]\
      \ = (1 if input_items[1][idx] > 0.5  else 0)\n                        j += 1\n\
      \                    else:\n                        break  # \u041F\u0440\u0435\
      \u0440\u044B\u0432\u0430\u0435\u043C \u0446\u0438\u043A\u043B, \u0435\u0441\u043B\
      \u0438 \u0438\u043D\u0434\u0435\u043A\u0441 \u0432\u044B\u0445\u043E\u0434\u0438\
      \u0442 \u0437\u0430 \u043F\u0440\u0435\u0434\u0435\u043B\u044B \u043C\u0430\u0441\
      \u0441\u0438\u0432\u0430\n                \n                # \u041F\u043E\u0441\
      \u043B\u0435 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u0438\u044F \u0432\
      \u044B\u0431\u043E\u0440\u043E\u043A \u043F\u0440\u043E\u0434\u043E\u043B\u0436\
      \u0430\u0435\u043C \u0441 \u043E\u0431\u044B\u0447\u043D\u044B\u043C \u0448\u0430\
      \u0433\u043E\u043C 4\n                i += (N - 1) * step\n                opora_found\
      \ = False  # \u041E\u043F\u043E\u0440\u0430 \u043E\u0431\u0440\u0430\u0431\u043E\
      \u0442\u0430\u043D\u0430, \u043F\u0440\u043E\u0434\u043E\u043B\u0436\u0430\u0435\
      \u043C \u0438\u0441\u043A\u0430\u0442\u044C \u043D\u043E\u0432\u0443\u044E\n\
      \            \n            i += 1  # \u0428\u0430\u0433 \u0432 \u043B\u044E\u0431\
      \u043E\u043C \u0441\u043B\u0443\u0447\u0430\u0435\n\n\n\n\n\n        # if (i\
      \ > (input_len - 11)):\n        #     return(i)\n\n        # TEST\n        #\
      \ output_items[0][0:output_len] = input_items[0][0:output_len]\n        # output_items[1][0:output_len]\
      \ = input_items[1][0:output_len]\n        # # \u0414\u0435\u043B\u0430\u0435\
      \u043C \u043A\u0430\u0436\u0434\u044B\u0439 4-\u0439 \u044D\u043B\u0435\u043C\
      \u0435\u043D\u0442 \u0440\u0430\u0432\u043D\u044B\u043C 100\n        # for i\
      \ in range(0, output_len, 4):\n        #     output_items[0][i] = 3\n      \
      \  #     output_items[1][i] = 3    \n\n\n        # while(i < (input_len)):\n\
      \            # mes = 0.0\n            # res = 0.0\n            # for mes in\
      \ input_items[0][i:i+3]:\n            #     res += mes\n            # res /=\
      \ 3\n            # res = (1 if res > 0.5  else 0)\n            # output_items[0][(i\
      \ // 3)] = int(res) \n            # # 1 - \u043D\u0430\u0439\u0442\u0438 \u043F\
      \u0435\u0440\u0435\u0445\u043E\u0434 1 -> 0\n            # mes = 0.0\n     \
      \       # res = 0.0\n            # for mes in input_items[1][i:i+3]:\n     \
      \       #     res += mes\n            # res = (1 if res > 0.5  else 0)\n   \
      \         # output_items[1][(i // 3)] = int(res) \n            # i += 3\n\n\n\
      \n\n\n\n            # 1 - \u043D\u0430\u0439\u0442\u0438 \u043F\u0435\u0440\u0435\
      \u0445\u043E\u0434 1 -> 0\n            # mes = 0.0\n            # res = 0.0\n\
      \            # for mes in input_items[0][i:i+4]:\n            #     res += mes\n\
      \            # res /= 4\n            # res = (1 if res > 0.5  else 0)\n    \
      \        # output_items[0][(i // 4)] = int(res) \n            # # 1 - \u043D\
      \u0430\u0439\u0442\u0438 \u043F\u0435\u0440\u0435\u0445\u043E\u0434 1 -> 0\n\
      \            # mes = 0.0\n            # res = 0.0\n            # for mes in\
      \ input_items[1][i:i+4]:\n            #     res += mes\n            # res /=\
      \ 4\n            # res = (1 if res > 0.5  else 0)\n            # output_items[1][(i\
      \ // 4)] = int(res) \n            # i += 4\n        # return (i)\n        return\
      \ (output_len)\n"
    affinity: ''
    alias: ''
    comment: ''
    example_param: '1.0'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Decode IQ QPSK', 'blk', [('example_param', '1.0')], [('0', 'float',
      1), ('1', 'float', 1)], [('0', 'float', 1), ('1', 'float', 1)], 'Embedded Python
      Block example - a simple multiply const', ['example_param'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [696, 336.0]
    rotation: 0
    state: disabled
- name: epy_block_1_0_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\nimport enum\n\n\n# class Scheduler(enum.Enum):\n# \
      \    first_channel = 0\n#     second_channel = 1\n#     deinit = 2\n\nclass\
      \ blk(gr.sync_block):  # other base classes are basic_block, decim_block, interp_block\n\
      \    \"\"\"Embedded Python Block example - a simple multiply const\"\"\"\n\n\
      \    def __init__(self, example_param=1.0):  # only default arguments here\n\
      \        \"\"\"arguments to this function show up as parameters in GRC\"\"\"\
      \n        gr.sync_block.__init__(\n            self,\n            name='Filter\
      \ IQ QPSK',   # will show up in GRC\n            in_sig=[np.float32, np.float32],\n\
      \            out_sig=[np.float32, np.float32]\n        )\n        # if an attribute\
      \ with the same name as a parameter is found,\n        # a callback is registered\
      \ (properties work, too).\n        self.example_param = example_param\n\n  \
      \  def work(self, input_items, output_items):\n        # WAIT = 10\n\n     \
      \   WAIT = 10 * 8 * 4\n        packet_size_bytes = 10  # \u0420\u0430\u0437\u043C\
      \u0435\u0440 \u043F\u0430\u043A\u0435\u0442\u0430 \u0432 \u0431\u0430\u0439\u0442\
      \u0430\u0445\n        packet_size_bits = packet_size_bytes * 8  # 10 \u0431\u0430\
      \u0439\u0442 = 80 \u0431\u0438\u0442\n        bit_size = 4  # \u0420\u0430\u0437\
      \u043C\u0435\u0440 \u0431\u0438\u0442\u0430 (\u0434\u043B\u044F \u0440\u0430\
      \u0441\u0447\u0435\u0442\u0430 \u0448\u0430\u0433\u0430 \u043F\u0440\u0438 \u0447\
      \u0442\u0435\u043D\u0438\u0438)\n        packet_size_mes = packet_size_bits\
      \ * bit_size  # 10 \u0431\u0430\u0439\u0442 = 80 \u0431\u0438\u0442\n      \
      \  # \"\u041F\u043B\u0430\u043D\u0438\u0440\u043E\u0432\u0449\u0438\u043A\"\
      \ \u0440\u0430\u0441\u043F\u0440\u0435\u0434\u0435\u043B\u044F\u044E\u0449\u0438\
      \u0439 \u043F\u043E \u043A\u0430\u043D\u0430\u043B\u0430\u043C (\u043A\u0442\
      \u043E \u0440\u0430\u043D\u044C\u0448\u0435 0->1, \u0442\u043E\u0442 \u043F\u0435\
      \u0440\u0432\u044B\u0439 \u043A\u0430\u043D\u0430\u043B) \n        # scheduler\
      \ = Scheduler.first_channel\n        scheduler = 0\n\n        # 1 - \u0417\u0430\
      \u043F\u043E\u043B\u043D\u0438\u0442\u044C \u0432\u044B\u0445\u043E\u0434\u043D\
      \u043E\u0439 \u043C\u0430\u0441\u0441\u0438\u0432 \u043D\u0443\u043B\u044F\u043C\
      \u0438\n        output_items[0].fill(0)\n        output_items[1].fill(0)\n \
      \       \n        i = 0\n        j = 0\n\n        exact_num_of_mes_per_bit =\
      \ 4.33\n        count_mes_per_pack = 0\n        prev_start = 0\n\n        output_len\
      \ = len(output_items[0])\n        input_len = len(input_items[0])\n\n      \
      \  # print(input_len, output_len)\n        test_mark = 0\n        \n\n     \
      \   chan_0_start_condition = False\n        chan_0_start_index = 0\n       \
      \ chan_1_start_condition = False\n        chan_1_start_index = 0\n        chan_num_0\
      \ = 0\n        chan_num_1 = 1\n\n        start_condition_found = False  # \u0424\
      \u043B\u0430\u0433, \u043D\u0430\u0439\u0434\u0435\u043D\u043E \u043B\u0438\
      \ start_condition\n        read_started = False  # \u0424\u043B\u0430\u0433\
      , \u043D\u0430\u0447\u0430\u043B\u043E\u0441\u044C \u043B\u0438 \u0447\u0442\
      \u0435\u043D\u0438\u0435\n        bits_read = 0  # \u0421\u0447\u0435\u0442\u0447\
      \u0438\u043A \u043F\u0440\u043E\u0447\u0438\u0442\u0430\u043D\u043D\u044B\u0445\
      \ \u0431\u0438\u0442\u043E\u0432\n\n        # \u041D\u0435 \u043D\u0430\u0434\
      \u043E \u0447\u0438\u0442\u0430\u0442\u044C \u0431\u0443\u0444\u0435\u0440,\
      \ \u0435\u0441\u043B\u0438 \u0432 \u043D\u0435\u0433\u043E \u043D\u0435 \u043C\
      \u043E\u0436\u0435\u0442 \u043F\u043E\u043C\u0435\u0441\u0442\u0438\u0442\u044C\
      \u0441\u044F \u043A\u0430\u043A \u043C\u0438\u043D\u0438\u0443\u043C 1 \u043F\
      \u043E\u043B\u043D\u043E\u0446\u0435\u043D\u043D\u044B\u0439 \u043F\u0430\u043A\
      \u0435\u0442\n        # \u0420\u0430\u0437\u043C\u0435\u0440 \u0431\u0443\u0444\
      \u0435\u0440\u0430 \u043F\u043E\u0447\u0435\u043C\u0443-\u0442\u043E \u043F\u043E\
      \u0441\u0442\u043E\u044F\u043D\u043D\u043E \u043C\u0435\u043D\u044F\u0435\u0442\
      \u0441\u044F \n        if (input_len < WAIT + packet_size_mes):\n          \
      \  return(output_len)\n\n        while i < (input_len - 7):\n            if\
      \ not start_condition_found:\n                # 1 - \u041B\u0438\u0431\u043E\
      \ \u043E\u0434\u043D\u043E\u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E,\
      \ \u043B\u0438\u0431\u043E \u0441 \u0448\u0430\u0433\u043E\u043C \u0432 1 \u043E\
      \u0431\u0430 \u043A\u0430\u043D\u0430\u043B\u0430 \u0434\u043E\u043B\u0436\u043D\
      \u044B \u043F\u0435\u0440\u0435\u0439\u0442\u0438 \u0432 1 \n              \
      \  # 1 - \u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C \u0443\u0441\
      \u043B\u043E\u0432\u0438\u0435: \u043E\u0431\u0430 \u043A\u0430\u043D\u0430\u043B\
      \u0430 \u043F\u043E\u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u0435\u043B\
      \u044C\u043D\u043E \u043F\u0435\u0440\u0435\u0448\u043B\u0438 \u043D\u0430 1\n\
      \                if input_items[0][i] > 0.4:\n                    if chan_0_start_condition\
      \ == False:\n                        chan_0_start_index = (i + 2 + 4)\n    \
      \                    chan_num_0 = scheduler            # \u043A\u0430\u043A\u0438\
      \u043C \u043A\u0430\u043D\u0430\u043B\u043E\u043C \u043D\u0430\u0437\u043D\u0430\
      \u0447\u0435\u043D \u043F\u0435\u0440\u0432\u044B\u0439\n                  \
      \      scheduler += 1\n                    chan_0_start_condition = True\n \
      \               if input_items[1][i] > 0.4:\n                    if chan_1_start_condition\
      \ == False:\n                        chan_1_start_index = (i + 2 + 4)\n    \
      \                    chan_num_1 = scheduler            # \u043A\u0430\u043A\u0438\
      \u043C \u043A\u0430\u043D\u0430\u043B\u043E\u043C \u043D\u0430\u0437\u043D\u0430\
      \u0447\u0435\u043D \u0432\u0442\u043E\u0440\u043E\u0439\n                  \
      \      scheduler += 1\n                    chan_1_start_condition = True\n\n\
      \                if (chan_0_start_condition and chan_1_start_condition):\n \
      \                   if (abs(chan_0_start_index - chan_1_start_index) < 4):\n\
      \                        start_condition_found = True\n                    \
      \    # print(i - test_mark)\n                        read_started = True\n \
      \                       bits_read = 0  # \u0421\u0431\u0440\u0430\u0441\u044B\
      \u0432\u0430\u0435\u043C \u0441\u0447\u0435\u0442\u0447\u0438\u043A \u043F\u0440\
      \u043E\u0447\u0438\u0442\u0430\u043D\u043D\u044B\u0445 \u0431\u0438\u0442\u043E\
      \u0432\n                    else:\n                        chan_0_start_condition\
      \ = False\n                        chan_1_start_condition = False\n        \
      \                # scheduler = Scheduler.first_channel\n                   \
      \     scheduler = 0\n                    # # \u041F\u043E\u0441\u0447\u0438\u0442\
      \u0430\u0435\u043C \u0442\u043E\u0447\u043D\u043E \u0441\u043A\u043E\u043B\u044C\
      \u043A\u043E \u0438\u0437\u043C\u0435\u0440\u0435\u043D\u0438\u0439 \u043F\u0440\
      \u0438\u0445\u043E\u0434\u0438\u0442\u0441\u044F \u043D\u0430 1 \u0431\u0438\
      \u0442\n                    # if prev_start != 0:\n                    #   \
      \  count_mes_per_pack = i - prev_start\n                    #     exact_num_of_mes_per_bit\
      \ = count_mes_per_pack / packet_size_bits\n                    #     print(exact_num_of_mes_per_bit)\n\
      \                    # prev_start = i\n\n                # if input_items[0][i]\
      \ > 0.5 and input_items[1][i] > 0.5:\n                #     start_condition_found\
      \ = True\n                #     read_started = True\n                #     bits_read\
      \ = 0  # \u0421\u0431\u0440\u0430\u0441\u044B\u0432\u0430\u0435\u043C \u0441\
      \u0447\u0435\u0442\u0447\u0438\u043A \u043F\u0440\u043E\u0447\u0438\u0442\u0430\
      \u043D\u043D\u044B\u0445 \u0431\u0438\u0442\u043E\u0432\n            else:\n\
      \                if read_started and (bits_read < packet_size_bits):\n     \
      \               # 2 - \u0427\u0438\u0442\u0430\u0435\u043C \u0431\u0438\u0442\
      \u044B \u0441 \u0442\u0435\u043A\u0443\u0449\u0435\u0433\u043E \u0438\u043D\u0434\
      \u0435\u043A\u0441\u0430 \u0441 \u0448\u0430\u0433\u043E\u043C exact_num_of_mes_per_bit\n\
      \                    if (i - chan_0_start_index) >= 0 and (i - chan_0_start_index)\
      \ % exact_num_of_mes_per_bit < 1.0:\n                        output_items[chan_num_0][j\
      \ // 2] = (1 if input_items[0][i] > 0.5 else 0)\n                        j +=\
      \ 1\n                        bits_read += 1\n                    if (i - chan_1_start_index)\
      \ >= 0 and (i - chan_1_start_index) % exact_num_of_mes_per_bit < 1.0:\n    \
      \                    output_items[chan_num_1][j // 2] = (1 if input_items[1][i]\
      \ > 0.5 else 0)\n                        j += 1\n                        bits_read\
      \ += 1\n                else:\n                    # \u0427\u0442\u0435\u043D\
      \u0438\u0435 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E, \u0441\u0431\
      \u0440\u0430\u0441\u044B\u0432\u0430\u0435\u043C \u0444\u043B\u0430\u0433 \u0438\
      \ \u0438\u0449\u0435\u043C \u043D\u043E\u0432\u043E\u0435 start_condition\n\
      \                    start_condition_found = False\n                    read_started\
      \ = False\n                    chan_0_start_condition = False\n            \
      \        chan_1_start_condition = False\n                    bits_read = 0\n\
      \                    scheduler = 0\n                    j += packet_size_bits\
      \ * 4   # (packet_size_bits * 2)    - \u043D\u0443\u043B\u0438 \u0438 \u043F\
      \u043E\u043B\u0435\u0437\u043D\u0430\u044F \u043D\u0430\u0433\u0440\u0443\u0437\
      \u043A\u0430\n                                                             \
      \               # (+ 1) - 0x3               - \u043D\u0430\u0447\u0430\u043B\
      \u043E \u0444\u0440\u0435\u0439\u043C\u0430\n                              \
      \                                              # (- packet_size_bits)      -\
      \ \u043C\u044B \u0443\u0436\u0435 \u043F\u0435\u0440\u0435\u0434\u0430\u043B\
      \u0438 1 \u043F\u0430\u043A\u0435\u0442 \u0431\u0438\u0442\u043E\u0432, \u043D\
      \u0430\u0434\u043E \u0438\u0445 \u0443\u0447\u0435\u0441\u0442\u044C\n     \
      \               stop_trig = 0\n                    # i += (WAIT / 2)\n     \
      \               while (i < input_len and stop_trig < (WAIT / 2)):\n        \
      \                if ((input_items[0][i] < 0.4) and (input_items[0][i] < 0.4)):\n\
      \                            stop_trig += 1\n                        else:\n\
      \                            # print(\"STOP: \", stop_trig)\n              \
      \              stop_trig = 0\n                        i += 1\n             \
      \       # print(\"END: \", stop_trig)\n                    test_mark = i\n\n\
      \            i += 1  # \u0428\u0430\u0433 \u0432 \u043B\u044E\u0431\u043E\u043C\
      \ \u0441\u043B\u0443\u0447\u0430\u0435\n\n        # output_items[0][0] = 2\n\
      \        # output_items[0][output_len - 1] = 3\n        # print(output_len)\n\
      \        # print(input_len)\n\n        return output_len\n"
    affinity: ''
    alias: ''
    comment: ''
    example_param: '1.0'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Filter IQ QPSK', 'blk', [('example_param', '1.0')], [('0', 'float',
      1), ('1', 'float', 1)], [('0', 'float', 1), ('1', 'float', 1)], 'Embedded Python
      Block example - a simple multiply const', ['example_param'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [688, 240.0]
    rotation: 0
    state: enabled
- name: epy_block_1_0_0_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\n# import enum\nimport time\n\n\nclass blk(gr.sync_block):\
      \  # other base classes are basic_block, decim_block, interp_block\n    \"\"\
      \"Embedded Python Block example - a simple multiply const\"\"\"\n\n    def __init__(self,\
      \ example_param=1.0):  # only default arguments here\n        \"\"\"arguments\
      \ to this function show up as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n\
      \            self,\n            name='Extract information IQ QPSK',   # will\
      \ show up in GRC\n            in_sig=[np.float32, np.float32],\n           \
      \ out_sig=[np.float32]\n        )\n        # if an attribute with the same name\
      \ as a parameter is found,\n        # a callback is registered (properties work,\
      \ too).\n        self.example_param = example_param\n\n    def work(self, input_items,\
      \ output_items):\n        i = 0\n        j = 0\n\n        res_msec = 0\n   \
      \     # num_good_bytes = 0\n        output_len = len(output_items[0])\n    \
      \    input_len = len(input_items[0])\n        packet_size_bytes = 10  # \u0420\
      \u0430\u0437\u043C\u0435\u0440 \u043F\u0430\u043A\u0435\u0442\u0430 \u0432 \u0431\
      \u0430\u0439\u0442\u0430\u0445\n        packet_size_bits = packet_size_bytes\
      \ * 8  # 10 \u0431\u0430\u0439\u0442 = 80 \u0431\u0438\u0442\n\n\n        while\
      \ i < output_len - packet_size_bytes * 8:\n            # 1 - \u043F\u0440\u043E\
      \u0447\u0438\u0442\u0430\u0442\u044C \u043F\u0430\u043A\u0435\u0442:\n     \
      \       packet_str = \"\"\n            readed_bytes = 0\n\n            start\
      \ = time.time()\n            while (readed_bytes < packet_size_bytes) and (i\
      \ < (output_len - 8)):\n                byte = 0\n                for n in range(0,\
      \ 4):\n                    byte <<= 2\n                    byte += int(input_items[1][i])\n\
      \                    byte += int(input_items[0][i] * 2)\n                  \
      \  i += 1\n                output_items[0][j] = byte\n                if 31\
      \ < byte < 127:\n                    pass\n                    # num_good_bytes\
      \ += 1\n                    # print(chr(byte), end = '')\n                 \
      \   # packet_str += chr(byte)\n                j += 1\n                readed_bytes\
      \ += 1\n            if j == 10:\n                finish = time.time()\n    \
      \            res = finish - start\n                res_msec = res * 1000\n \
      \           # 2 - \u043F\u0440\u043E\u043F\u0443\u0441\u0442\u0438\u0442\u044C\
      \ \u043D\u0443\u043B\u0438\n            # print(packet_str, end = '')\n    \
      \        # print(packet_str)\n            # i += (packet_size_bits * 4)\n\n\
      \        # print('\u0412\u0440\u0435\u043C\u044F \u0440\u0430\u0431\u043E\u0442\
      \u044B \u0432 \u043C\u0438\u043B\u043B\u0438\u0441\u0435\u043A\u0443\u043D\u0434\
      \u0430\u0445: ', res_msec)\n        # print('\u0445\u043E\u0440\u043E\u0448\u0438\
      \u0445 \u0431\u0430\u0439\u0442: ', num_good_bytes)\n\n        return output_len\n"
    affinity: ''
    alias: ''
    comment: ''
    example_param: '1.0'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Extract information IQ QPSK', 'blk', [('example_param', '1.0')],
      [('0', 'float', 1), ('1', 'float', 1)], [('0', 'float', 1)], 'Embedded Python
      Block example - a simple multiply const', ['example_param'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [968, 408.0]
    rotation: 0
    state: enabled
- name: qtgui_time_sink_x_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '""'
    nconnections: '2'
    size: 1024*16
    srate: '100000'
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: float
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1016, 272.0]
    rotation: 0
    state: disabled
- name: qtgui_time_sink_x_0_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '"Witout"'
    nconnections: '2'
    size: 1024*16
    srate: '100000'
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: float
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [624, 424.0]
    rotation: 0
    state: true
- name: qtgui_time_sink_x_0_1
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '""'
    nconnections: '1'
    size: 1024 * 16
    srate: '100000'
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: float
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1272, 208.0]
    rotation: 0
    state: disabled
- name: qtgui_time_sink_x_0_2
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '""'
    nconnections: '1'
    size: 1024*16
    srate: '100000'
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: float
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1240, 400.0]
    rotation: 0
    state: enabled

connections:
- [blocks_char_to_float_0, '0', qtgui_time_sink_x_0_1, '0']
- [blocks_float_to_char_0, '0', blocks_stream_mux_0, '0']
- [blocks_float_to_char_0_0, '0', blocks_stream_mux_0, '1']
- [blocks_multiply_const_vxx_0, '0', epy_block_1_0, '0']
- [blocks_multiply_const_vxx_0, '0', epy_block_1_0_0, '0']
- [blocks_multiply_const_vxx_0, '0', qtgui_time_sink_x_0_0, '0']
- [blocks_multiply_const_vxx_0_0, '0', epy_block_1_0, '1']
- [blocks_multiply_const_vxx_0_0, '0', epy_block_1_0_0, '1']
- [blocks_multiply_const_vxx_0_0, '0', qtgui_time_sink_x_0_0, '1']
- [blocks_null_source_0, '0', epy_block_0_0, '0']
- [blocks_null_source_0_0, '0', epy_block_0_0, '1']
- [blocks_null_source_0_0_0, '0', blocks_float_to_char_0_0, '0']
- [blocks_null_source_0_1, '0', epy_block_1, '0']
- [blocks_null_source_0_2, '0', blocks_float_to_char_0, '0']
- [blocks_pack_k_bits_bb_0, '0', blocks_char_to_float_0, '0']
- [blocks_stream_mux_0, '0', blocks_pack_k_bits_bb_0, '0']
- [epy_block_0_0, '0', blocks_multiply_const_vxx_0, '0']
- [epy_block_0_0, '1', blocks_multiply_const_vxx_0_0, '0']
- [epy_block_1_0, '0', qtgui_time_sink_x_0, '0']
- [epy_block_1_0, '1', qtgui_time_sink_x_0, '1']
- [epy_block_1_0_0, '0', blocks_float_to_char_0, '0']
- [epy_block_1_0_0, '0', epy_block_1_0_0_0, '0']
- [epy_block_1_0_0, '0', qtgui_time_sink_x_0, '0']
- [epy_block_1_0_0, '1', blocks_float_to_char_0_0, '0']
- [epy_block_1_0_0, '1', epy_block_1_0_0_0, '1']
- [epy_block_1_0_0, '1', qtgui_time_sink_x_0, '1']
- [epy_block_1_0_0_0, '0', qtgui_time_sink_x_0_2, '0']

metadata:
  file_format: 1
  grc_version: 3.10.8.0
