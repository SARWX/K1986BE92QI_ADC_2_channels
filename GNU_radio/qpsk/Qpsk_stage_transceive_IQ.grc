options:
  parameters:
    author: Barry Duggan
    catch_exceptions: 'True'
    category: Custom
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: qpsk_stage6
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: qpsk_stage6
    window_size: 2000,2000
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [16, 16.0]
    rotation: 0
    state: enabled

blocks:
- name: analog_const_source_x_0
  id: analog_const_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    const: '10'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [32, 136.0]
    rotation: 0
    state: true
- name: analog_random_source_x_0
  id: analog_random_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    max: '255'
    maxoutbuf: '0'
    min: '0'
    minoutbuf: '0'
    num_samps: '1000'
    repeat: 'True'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 288.0]
    rotation: 0
    state: true
- name: blocks_add_const_vxx_1
  id: blocks_add_const_vxx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    const: '-1'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [776, 296.0]
    rotation: 0
    state: true
- name: blocks_add_const_vxx_1_0
  id: blocks_add_const_vxx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    const: '-1'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [776, 232.0]
    rotation: 0
    state: true
- name: blocks_char_to_float_0_0_0
  id: blocks_char_to_float
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    scale: '1'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [408, 384.0]
    rotation: 0
    state: enabled
- name: blocks_char_to_float_0_0_0_0
  id: blocks_char_to_float
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    scale: '1'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [632, 232.0]
    rotation: 0
    state: enabled
- name: blocks_char_to_float_0_0_0_1
  id: blocks_char_to_float
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    scale: '1'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [624, 296.0]
    rotation: 0
    state: enabled
- name: blocks_null_sink_0
  id: blocks_null_sink
  parameters:
    affinity: ''
    alias: ''
    bus_structure_sink: '[[0,],]'
    comment: ''
    num_inputs: '1'
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1232, 224.0]
    rotation: 0
    state: true
- name: blocks_null_sink_0_0
  id: blocks_null_sink
  parameters:
    affinity: ''
    alias: ''
    bus_structure_sink: '[[0,],]'
    comment: ''
    num_inputs: '1'
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1232, 288.0]
    rotation: 0
    state: true
- name: blocks_null_sink_1
  id: blocks_null_sink
  parameters:
    affinity: ''
    alias: ''
    bus_structure_sink: '[[0,],]'
    comment: ''
    num_inputs: '1'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [216, 320.0]
    rotation: 0
    state: true
- name: blocks_stream_demux_0
  id: blocks_stream_demux
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    lengths: (1, 1)
    maxoutbuf: '0'
    minoutbuf: '0'
    num_outputs: '2'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [416, 248.0]
    rotation: 0
    state: true
- name: blocks_unpack_k_bits_bb_0_0
  id: blocks_unpack_k_bits_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    k: '8'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [200, 256.0]
    rotation: 0
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport serial\nimport\
      \ serial.tools.list_ports\nimport time\n\nimport numpy as np\nfrom gnuradio\
      \ import gr\nimport pmt\n\nMAX_DAC_NUM = 500   # \u041C\u0430\u043A\u0441\u0438\
      \u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\
      \u0441\u0442\u0432\u043E \u0447\u0438\u0441\u0435\u043B, \u043A\u043E\u0442\u043E\
      \u0440\u043E\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u0437\
      \u0430\u043F\u0438\u0441\u0430\u043D\u043E \u0432 const_signal\nMAX_DAC_VAL\
      \ = 10.0  # \u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\
      \u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u043D\u0430 \u0432\u044B\
      \u0445\u043E\u0434\u0435 \u0426\u0410\u041F\nCHUNK_SIZE = 10     # \u041C\u0430\
      \u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u043A\u043E\u043B\
      \u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0447\u0438\u0441\u0435\u043B \u0432\
      \ \u043E\u0434\u043D\u043E\u0439 \u043A\u043E\u043C\u0430\u043D\u0434\u0435\n\
      USB_PACKET_SIZE = 32 # \u0431\u0430\u0439\u0442\n# USB_PACKET_SIZE = 256 # \u0431\
      \u0430\u0439\u0442              \u0414\u041B\u042F dac mode\n\n\nclass ADIBlock(gr.sync_block):\
      \  # other base classes are basic_block, decim_block, interp_block\n    \"\"\
      \"\n    Read data from serial port and forward it to output. \n    portNumber\
      \ is number, you can see in the name of your \n    serial port in device manager,\
      \ like COM16 or COM7 \n    \"\"\"\n\n    \n    def __init__(self, portNumber=7,\
      \ mode = 3): \n        \"\"\"arguments to this function show up as parameters\
      \ in GRC\"\"\"\n        self.portNumber = portNumber  # \u0421\u043E\u0445\u0440\
      \u0430\u043D\u044F\u0435\u043C \u043D\u043E\u043C\u0435\u0440 \u043F\u043E\u0440\
      \u0442\u0430\n        # portName = 'COM' + str(portNumber)                 \
      \ # Concatenate string and number\n        \n        gr.sync_block.__init__(\n\
      \            self,\n            name = 'Analog Digital Interface',   \n    \
      \        in_sig = [np.float32, np.float32],                # \u0412\u0445\u043E\
      \u0434\u044B\n            out_sig = [np.float32, np.float32]  # \u0412\u044B\
      \u0445\u043E\u0434\u044B\n        )\n\n        # \u0420\u0435\u0433\u0438\u0441\
      \u0442\u0440\u0430\u0446\u0438\u044F \u0438\u043C\u0435\u043D\u043E\u0432\u0430\
      \u043D\u043D\u044B\u0445 \u0432\u0445\u043E\u0434\u043D\u044B\u0445 \u0438 \u0432\
      \u044B\u0445\u043E\u0434\u043D\u044B\u0445 \u043F\u043E\u0440\u0442\u043E\u0432\
      \n        self.message_port_register_in(pmt.intern('set_const_signal'))\n  \
      \      self.set_msg_handler(pmt.intern('set_const_signal'), self.handle_msg)\n\
      \        # self.message_port_register_out(pmt.intern('msg_out'))\n\n       \
      \  # \u0418\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0430\u0446\u0438\
      \u044F \u043F\u0435\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0445 \u0434\u043B\
      \u044F COM \u043F\u043E\u0440\u0442\u0430\n        self.port = None\n      \
      \  self.port_name = None\n        self.baudrate = 2000000  # \u0417\u0434\u0435\
      \u0441\u044C \u0437\u0430\u0445\u0430\u0440\u0434\u043A\u043E\u0436\u0435\u043D\
      \ baudrate\n        self.mode = mode\n        self.remaining_data = bytearray(USB_PACKET_SIZE\
      \ + 1)  # \u0411\u0443\u0444\u0435\u0440 \u0434\u043B\u044F \u043E\u0441\u0442\
      \u0430\u0432\u0448\u0438\u0445\u0441\u044F \u0434\u0430\u043D\u043D\u044B\u0445\
      \     0\u043E\u0439 \u0431\u0430\u0439\u0442 - \u0444\u043B\u0430\u0433 (0 -\
      \ \u0432 \u043C\u0430\u0441\u0441\u0438\u0432\u0435 \u043D\u0435\u0442 \u043F\
      \u043E\u043B\u0435\u0437\u043D\u044B\u0445 \u0434\u0430\u043D\u043D\u044B\u0445\
      , 1 - \u043D\u0430\u0434\u043E \u0447\u0438\u0442\u0430\u0442\u044C)\n     \
      \   \n    def open_port(self):\n        \"\"\"\u041E\u0442\u043A\u0440\u044B\
      \u0432\u0430\u0435\u0442 COM \u043F\u043E\u0440\u0442, \u0435\u0441\u043B\u0438\
      \ \u043E\u043D \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442\
      \ \u0438 \u043D\u0435 \u0437\u0430\u043D\u044F\u0442.\"\"\"\n        baudrate\
      \ = 2000000\n        portName = 'COM' + str(self.portNumber)\n\n        # \u041F\
      \u043E\u043B\u0443\u0447\u0430\u0435\u043C \u0441\u043F\u0438\u0441\u043E\u043A\
      \ \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u0445 COM \u043F\u043E\u0440\
      \u0442\u043E\u0432\n        available_ports = [port.device for port in serial.tools.list_ports.comports()]\n\
      \n        if portName not in available_ports:\n            print(f\"\u041E\u0448\
      \u0438\u0431\u043A\u0430: \u041F\u043E\u0440\u0442 {portName} \u043D\u0435 \u043D\
      \u0430\u0439\u0434\u0435\u043D.\")\n            return\n        \n        try:\n\
      \            # \u041F\u044B\u0442\u0430\u0435\u043C\u0441\u044F \u043E\u0442\
      \u043A\u0440\u044B\u0442\u044C \u043F\u043E\u0440\u0442\n            self.port\
      \ = serial.Serial(portName, baudrate, timeout=3.0)\n            # \u0415\u0441\
      \u043B\u0438 \u043F\u043E\u0440\u0442 \u0443\u0436\u0435 \u0431\u044B\u043B\
      \ \u043E\u0442\u043A\u0440\u044B\u0442, \u0437\u0430\u043A\u0440\u044B\u0432\
      \u0430\u0435\u043C \u0435\u0433\u043E \u0438 \u043E\u0442\u043A\u0440\u044B\u0432\
      \u0430\u0435\u043C \u0437\u0430\u043D\u043E\u0432\u043E\n            if self.port.is_open:\n\
      \                self.port.close()\n                self.port.open()\n     \
      \       else:\n                self.port.open()\n            print(f\"\u041F\
      \u043E\u0440\u0442 {portName} \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043E\
      \u0442\u043A\u0440\u044B\u0442.\")\n        except serial.SerialException as\
      \ e:\n            # \u0415\u0441\u043B\u0438 \u043D\u0435 \u0443\u0434\u0430\
      \u043B\u043E\u0441\u044C \u043E\u0442\u043A\u0440\u044B\u0442\u044C \u043F\u043E\
      \u0440\u0442 (\u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043E\u043D\
      \ \u0437\u0430\u043D\u044F\u0442), \u0432\u044B\u0432\u043E\u0434\u0438\u043C\
      \ \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0435 \u043E\u0431 \u043E\
      \u0448\u0438\u0431\u043A\u0435\n            print(f\"\u041E\u0448\u0438\u0431\
      \u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043A\u0440\u044B\u0442\u0438\u0438\
      \ \u043F\u043E\u0440\u0442\u0430 {portName}: {e}\")\n            self.port =\
      \ None\n\n\n    def set_mode(self, mode_setting):\n        if mode_setting <\
      \ 4:\n            command = \"mode \" + str(mode_setting)  \n        else:\n\
      \            command = \"dac_mode\"\n        try:\n            self.port.write(command.encode('ascii'))\n\
      \            print(f\"\u041E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\
      \u043E: {command}\")\n            time.sleep(0.01)\n        except serial.SerialException\
      \ as e:\n            print(f\"\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\
      \u0438 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0435 \u0434\u0430\u043D\u043D\
      \u044B\u0445: {e}\")\n\n\n    def handle_msg(self, msg):\n        \"\"\"\u041E\
      \u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u0432\u0445\u043E\u0434\u043D\
      \u044B\u0445 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0439.\"\"\"\n\
      \        # \u041F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\
      \u043D\u0438\u0435 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u044F \u0432\
      \ \u0441\u043F\u0438\u0441\u043E\u043A \u0447\u0438\u0441\u0435\u043B \u0441\
      \ \u043F\u043B\u0430\u0432\u0430\u044E\u0449\u0435\u0439 \u0437\u0430\u043F\u044F\
      \u0442\u043E\u0439\n        numbers = pmt.to_python(msg)        # \u041F\u0440\
      \u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D\u0438\u0435 \u0432\
      \ \u0441\u0442\u0440\u043E\u043A\u0443\n        numbers = [float(x) for x in\
      \ numbers.split()]\n        print(\"AAAAAAAAAAAAAAAAAAAAAA\")\n        # print(numbers[30])\n\
      \n        # if not isinstance(numbers, list):\n        #     print(\"\u041E\u0448\
      \u0438\u0431\u043A\u0430: \u041E\u0436\u0438\u0434\u0430\u043B\u0441\u044F \u0441\
      \u043F\u0438\u0441\u043E\u043A \u0447\u0438\u0441\u0435\u043B.\")\n        #\
      \     return\n\n        if len(numbers) > MAX_DAC_NUM:\n            print(f\"\
      \u041E\u0448\u0438\u0431\u043A\u0430: \u0421\u043B\u0438\u0448\u043A\u043E\u043C\
      \ \u043C\u043D\u043E\u0433\u043E \u0447\u0438\u0441\u0435\u043B. \u041C\u0430\
      \u043A\u0441\u0438\u043C\u0443\u043C {MAX_DAC_NUM}.\")\n            return\n\
      \n        if any(val > MAX_DAC_VAL for val in numbers):\n            print(f\"\
      \u041E\u0448\u0438\u0431\u043A\u0430: \u0417\u043D\u0430\u0447\u0435\u043D\u0438\
      \u044F \u043D\u0435 \u043C\u043E\u0433\u0443\u0442 \u043F\u0440\u0435\u0432\u044B\
      \u0448\u0430\u0442\u044C {MAX_DAC_VAL}.\")\n            return\n\n        #\
      \ \u041E\u0442\u043A\u0440\u044B\u0442\u0438\u0435 \u043F\u043E\u0440\u0442\u0430\
      , \u0435\u0441\u043B\u0438 \u0435\u0449\u0435 \u043D\u0435 \u043E\u0442\u043A\
      \u0440\u044B\u0442\n        if self.port is None:\n            self.open_port()\n\
      \n        if self.port is not None and self.port.is_open:\n            # \u0420\
      \u0430\u0437\u0434\u0435\u043B\u0435\u043D\u0438\u0435 \u0434\u0430\u043D\u043D\
      \u044B\u0445 \u043D\u0430 \u043A\u0443\u0441\u043A\u0438 \u043F\u043E 10 \u0447\
      \u0438\u0441\u0435\u043B \u0438 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0430\
      \n            for i in range(0, len(numbers), CHUNK_SIZE):\n               \
      \ chunk = numbers[i:i + CHUNK_SIZE]\n                command = \"set \" + \"\
      \ \".join(map(str, chunk))\n                if i + CHUNK_SIZE >= len(numbers):\n\
      \                    command += \" !\"\n                \n                try:\n\
      \                    self.port.write(command.encode('ascii'))\n            \
      \        print(f\"\u041E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E\
      : {command}\")\n                    time.sleep(0.01)\n                except\
      \ serial.SerialException as e:\n                    print(f\"\u041E\u0448\u0438\
      \u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\
      \u0435 \u0434\u0430\u043D\u043D\u044B\u0445: {e}\")\n\n\n            \n    def\
      \ work(self, input_items, output_items):\n\n        if self.port is None:\n\
      \            # \u0415\u0441\u043B\u0438 \u043F\u043E\u0440\u0442 \u043D\u0435\
      \ \u043E\u0442\u043A\u0440\u044B\u0442, \u043F\u043E\u043F\u044B\u0442\u0430\
      \u0442\u044C\u0441\u044F \u043E\u0442\u043A\u0440\u044B\u0442\u044C \u0435\u0433\
      \u043E\n            self.open_port()\n            self.set_mode(self.mode)\n\
      \n        # \u0421\u043B\u0443\u0447\u0430\u0439 \u043E\u0431\u044B\u0447\u043D\
      \u043E\u0439 \u0440\u0430\u0431\u043E\u0442\u044B (\u0423\u043F\u043E\u0440\
      \ \u043D\u0430 \u0410\u0426\u041F)\n        if self.mode < 4:\n            n\
      \ = 0\n            chunk_size = USB_PACKET_SIZE\n            output_len = len(output_items[0])\n\
      \            # print (output_len)\n            data = bytearray(chunk_size)\
      \  # \u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u043C\u0430\u0441\u0441\
      \u0438\u0432\u0430 \u0431\u0430\u0439\u0442\u043E\u0432 \u0434\u043B\u044F \u0447\
      \u0442\u0435\u043D\u0438\u044F \u0434\u0430\u043D\u043D\u044B\u0445\n      \
      \      n_increment = (USB_PACKET_SIZE if self.mode < 3 else (USB_PACKET_SIZE\
      \ // 2))\n\n                \n            while n < (output_len - n_increment):\n\
      \                chunk_size = USB_PACKET_SIZE\n            \n              \
      \  # \u041E\u0431\u044A\u0435\u0434\u0438\u043D\u044F\u0435\u043C \u043E\u0441\
      \u0442\u0430\u0442\u043E\u0447\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\
      \u0435 \u0438\u0437 \u043F\u0440\u0435\u0434\u044B\u0434\u0443\u0449\u0435\u0439\
      \ \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0438 \u0441 \u043D\u043E\u0432\
      \u044B\u043C\u0438\n                if self.remaining_data[0] == 1:\n      \
      \              # data = bytearray(chunk_size)  # \u0421\u043E\u0437\u0434\u0430\
      \u043D\u0438\u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u0430 \u0431\u0430\u0439\
      \u0442\u043E\u0432 \u0434\u043B\u044F \u0447\u0442\u0435\u043D\u0438\u044F \u0434\
      \u0430\u043D\u043D\u044B\u0445\n                    chunk_size = len(self.remaining_data)\
      \ - 1\n                    data = bytearray(chunk_size)\n                  \
      \  data = self.remaining_data[1:]       # \u0421\u043E\u0445\u0440\u0430\u043D\
      \u0438\u0442\u044C \u0434\u0430\u043D\u043D\u044B\u0435 \n                 \
      \   # print (data)\n                    # data[-1:] = b'\\x00'\n           \
      \         # print(len(self.remaining_data))\n                    # print(data)\n\
      \                    # print(\"YES\")\n                    # while True:\n \
      \                   #     pass\n                    self.remaining_data = bytearray(USB_PACKET_SIZE\
      \ + 1)  # \u041E\u0447\u0438\u0449\u0430\u0435\u043C \u0431\u0443\u0444\u0435\
      \u0440\n                else:\n                    data = bytearray(chunk_size)\
      \  # \u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u043C\u0430\u0441\u0441\
      \u0438\u0432\u0430 \u0431\u0430\u0439\u0442\u043E\u0432 \u0434\u043B\u044F \u0447\
      \u0442\u0435\u043D\u0438\u044F \u0434\u0430\u043D\u043D\u044B\u0445\n      \
      \              self.port.readinto(data)  # \u0421\u0447\u0438\u0442\u044B\u0432\
      \u0430\u043D\u0438\u0435 \u0434\u0430\u043D\u043D\u044B\u0445 \u043D\u0435\u043F\
      \u043E\u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0435\u043D\u043D\u043E \u0432\
      \ \u043C\u0430\u0441\u0441\u0438\u0432 \u0431\u0430\u0439\u0442\u043E\u0432\n\
      \n                if self.mode < 2:  # mode can be 0 or 1, \u043E\u0431\u0430\
      \ \u0432\u043A\u043B\u044E\u0447\u0430\u044E\u0442 \u0442\u043E\u043B\u044C\u043A\
      \u043E 1 \u043A\u0430\u043D\u0430\u043B \u0410\u0426\u041F\n               \
      \     output_items[0][n:n + chunk_size] = data[:chunk_size]\n              \
      \      n += chunk_size\n                else:\n                    # TEST 8\
      \ bit\n                    output_items[0][n:n + chunk_size // 2] = data[0::2]\n\
      \                    output_items[1][n:n + chunk_size // 2] = data[1::2]\n \
      \                   # output_items[1][n] = b'\\x30'\n                    n +=\
      \ chunk_size // 2\n\n                    # TESST\n\n            # \u041E\u0431\
      \u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0441\u0442\u0430\u0432\u0448\
      \u0435\u0433\u043E\u0441\u044F \u043C\u0435\u0441\u0442\u0430 \u0432 output_items\n\
      \            if n < output_len:\n                self.port.readinto(data)  #\
      \ \u0421\u0447\u0438\u0442\u044B\u0432\u0430\u0435\u043C \u0434\u0430\u043D\u043D\
      \u044B\u0435 \u0432 \u043C\u0430\u0441\u0441\u0438\u0432 \u0431\u0430\u0439\u0442\
      \u043E\u0432\n                if self.mode < 2:  # mode can be 0 \u0438\u043B\
      \u0438 1, \u043E\u0431\u0430 \u0432\u043A\u043B\u044E\u0447\u0430\u044E\u0442\
      \ \u0442\u043E\u043B\u044C\u043A\u043E 1 \u043A\u0430\u043D\u0430\u043B \u0410\
      \u0426\u041F\n                    bytes_to_copy = min(chunk_size, output_len\
      \ - n)\n                    output_items[0][n:n + bytes_to_copy] = data[:bytes_to_copy]\n\
      \                    n += bytes_to_copy\n                    self.remaining_data\
      \ = data[bytes_to_copy:]  # \u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0435\
      \u043C \u043E\u0441\u0442\u0430\u0432\u0448\u0438\u0435\u0441\u044F \u0434\u0430\
      \u043D\u043D\u044B\u0435\n                else:\n                    i = 0\n\
      \                    # print(n)\n                    while n < output_len and\
      \ i < chunk_size:\n                        output_items[0][n] = data[i] \n \
      \                       output_items[1][n] = data[i + 1]\n                 \
      \       n += 1\n                        i += 2\n                    # output_items[1][n-1]\
      \ = 300\n                    self.remaining_data = bytearray(USB_PACKET_SIZE\
      \ - i + 1)\n                    self.remaining_data[1:] = data[i:]  # \u0421\
      \u043E\u0445\u0440\u0430\u043D\u044F\u0435\u043C \u043E\u0441\u0442\u0430\u0432\
      \u0448\u0438\u0435\u0441\u044F \u0434\u0430\u043D\u043D\u044B\u0435\n      \
      \              self.remaining_data[0] = (0 if (USB_PACKET_SIZE - i) == 0 else\
      \ 1)  # \u0424\u043B\u0430\u0433 \u0437\u0430\u043F\u0440\u043E\u0441\u0430\
      \ \u0447\u0442\u0435\u043D\u0438\u044F\n                    # print(n)\n   \
      \                 # print(self.remaining_data)\n\n            return len(output_items[0])\
      \  # \u0412\u043E\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043C \u043A\u043E\
      \u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043E\u0431\u0440\u0430\u0431\
      \u043E\u0442\u0430\u043D\u043D\u044B\u0445 \u044D\u043B\u0435\u043C\u0435\u043D\
      \u0442\u043E\u0432\n\n\n\n\n                # \u0421\u043B\u0443\u0447\u0430\
      \u0439, \u043A\u043E\u0433\u0434\u0430 mode >= 4 (dac_mode) - \u0443\u043F\u043E\
      \u0440 \u043D\u0430 \u0426\u0410\u041F, \u0410\u0426\u041F \u043E\u0442\u043A\
      \u043B\u044E\u0447\u0435\u043D\n        # \u0421\u043B\u0443\u0447\u0430\u0439\
      , \u043A\u043E\u0433\u0434\u0430 mode >= 4 (dac_mode) - \u0443\u043F\u043E\u0440\
      \ \u043D\u0430 \u0426\u0410\u041F, \u0410\u0426\u041F \u043E\u0442\u043A\u043B\
      \u044E\u0447\u0435\u043D\n        else:\n            data = bytearray(USB_PACKET_SIZE\
      \ )  # \u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u043C\u0430\u0441\u0441\
      \u0438\u0432\u0430 \u0431\u0430\u0439\u0442\u043E\u0432 \u0434\u043B\u044F \u0447\
      \u0442\u0435\u043D\u0438\u044F \u0434\u0430\u043D\u043D\u044B\u0445\n      \
      \      n = 0\n            remaining_len = 0\n            input_len = min(len(input_items[0]),\
      \ len(input_items[1]))  # \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\
      \u043C \u043C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\u043D\u0443\u044E \u0434\
      \u043B\u0438\u043D\u0443 \u0434\u043B\u044F \u0438\u0437\u0431\u0435\u0436\u0430\
      \u043D\u0438\u044F \u0432\u044B\u0445\u043E\u0434\u0430 \u0437\u0430 \u0433\u0440\
      \u0430\u043D\u0438\u0446\u044B\n\n            # \u0415\u0441\u043B\u0438 \u0435\
      \u0441\u0442\u044C remaining_data, \u043E\u0431\u044A\u0435\u0434\u0438\u043D\
      \u044F\u0435\u043C \u0435\u0433\u043E \u0441 \u0442\u0435\u043A\u0443\u0449\u0438\
      \u043C\u0438 \u0434\u0430\u043D\u043D\u044B\u043C\u0438\n            if self.remaining_data:\n\
      \                remaining_len = len(self.remaining_data)\n                #\
      \ \u0423\u0432\u0435\u043B\u0438\u0447\u0438\u0432\u0430\u0435\u043C \u0440\u0430\
      \u0437\u043C\u0435\u0440 \u0431\u0443\u0444\u0435\u0440\u0430, \u0434\u043E\u0431\
      \u0430\u0432\u043B\u044F\u044F \u0434\u043B\u0438\u043D\u0443 remaining_data\n\
      \                data = self.remaining_data + data[:USB_PACKET_SIZE  - remaining_len]\
      \  # \u041E\u0433\u0440\u0430\u043D\u0438\u0447\u0438\u0432\u0430\u0435\u043C\
      \ data \u043F\u043E \u0440\u0430\u0437\u043C\u0435\u0440\u0443\n           \
      \     self.remaining_data = bytearray()  # \u041E\u0447\u0438\u0449\u0430\u0435\
      \u043C \u0431\u0443\u0444\u0435\u0440 \u043F\u043E\u0441\u043B\u0435 \u043E\u0431\
      \u044A\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u044F\n\n            while\
      \ n < input_len:\n                i = remaining_len  # \u0421\u0431\u0440\u0430\
      \u0441\u044B\u0432\u0430\u0435\u043C \u0438\u043D\u0434\u0435\u043A\u0441 \u0434\
      \u043B\u044F data\n\n                while i < (USB_PACKET_SIZE ) and n < input_len:\
      \  # \u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C \u0438 n\n     \
      \               value1 = int((input_items[0][n] + 1) * 4000 / 2) & 0xFFF  #\
      \ \u041F\u0440\u0438\u0432\u0435\u0434\u0435\u043D\u0438\u0435 \u043A \u0446\
      \u0435\u043B\u043E\u043C\u0443 \u0447\u0438\u0441\u043B\u0443 \u0438 \u043E\u0433\
      \u0440\u0430\u043D\u0438\u0447\u0435\u043D\u0438\u0435 \u0434\u043E 16 \u0431\
      \u0438\u0442\n                    data[i] = value1 & 0xFF  # \u041C\u043B\u0430\
      \u0434\u0448\u0438\u0439 \u0431\u0430\u0439\u0442\n                    data[i\
      \ + 1] = (value1 >> 8) & 0xFF  # \u0421\u0442\u0430\u0440\u0448\u0438\u0439\
      \ \u0431\u0430\u0439\u0442\n                    i += 2\n                   \
      \ value2 = int((input_items[1][n] + 1) * 4000 / 2) & 0xFFF  # \u041F\u0440\u0438\
      \u0432\u0435\u0434\u0435\u043D\u0438\u0435 \u043A \u0446\u0435\u043B\u043E\u043C\
      \u0443 \u0447\u0438\u0441\u043B\u0443 \u0438 \u043E\u0433\u0440\u0430\u043D\u0438\
      \u0447\u0435\u043D\u0438\u0435 \u0434\u043E 16 \u0431\u0438\u0442\n        \
      \            data[i] = value2 & 0xFF  # \u041C\u043B\u0430\u0434\u0448\u0438\
      \u0439 \u0431\u0430\u0439\u0442\n                    data[i + 1] = (value2 >>\
      \ 8) & 0xFF  # \u0421\u0442\u0430\u0440\u0448\u0438\u0439 \u0431\u0430\u0439\
      \u0442\n                    i += 2\n                    n += 1\n\n         \
      \       # \u041E\u0442\u043F\u0440\u0430\u0432\u043B\u044F\u0435\u043C \u0441\
      \u043E\u0431\u0440\u0430\u043D\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\
      \u0435 \u0432 \u043F\u043E\u0440\u0442\n                self.port.write(data)\
      \  # \u041E\u0442\u043F\u0440\u0430\u0432\u043B\u044F\u0435\u043C \u0442\u043E\
      \u043B\u044C\u043A\u043E \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u043D\
      \u0443\u044E \u0447\u0430\u0441\u0442\u044C\n                remaining_len =\
      \ 0\n                data = bytearray(USB_PACKET_SIZE )\n\n            # \u041E\
      \u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0441\u0442\u0430\u0432\
      \u0448\u0438\u0445\u0441\u044F \u0434\u0430\u043D\u043D\u044B\u0445\n      \
      \      if n < input_len:\n                remaining_data = bytearray()\n\n \
      \               while n < input_len and i < USB_PACKET_SIZE :\n            \
      \        value1 = int((input_items[0][n] + 1) * 4000 / 2) & 0xFFF\n        \
      \            remaining_data.append(value1 & 0xFF)\n                    remaining_data.append((value1\
      \ >> 8) & 0xFF)\n                    i += 2\n                    value2 = int((input_items[1][n]\
      \ + 1) * 4000 / 2) & 0xFFF\n                    remaining_data.append(value2\
      \ & 0xFF)\n                    remaining_data.append((value2 >> 8) & 0xFF)\n\
      \                    i += 2\n                    n += 1\n\n                #\
      \ \u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0435\u043C \u043E\u0441\u0442\u0430\
      \u0442\u043E\u0447\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435 \u0434\
      \u043B\u044F \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E \u0432\
      \u044B\u0437\u043E\u0432\u0430\n                self.remaining_data = remaining_data\n\
      \n            return len(input_items[0])\n\n"
    affinity: ''
    alias: ''
    comment: "mode = 0,    // 1\u044B\u0439 \u043A\u0430\u043D\u0430\u043B \u0410\u0426\
      \u041F, 1\u044B\u0439 \u043A\u0430\u043D\u0430\u043B \u0426\u0410\u041F \nmode\
      \  = 1,    // 1\u044B\u0439 \u043A\u0430\u043D\u0430\u043B \u0410\u0426\u041F\
      , 2 \u043A\u0430\u043D\u0430\u043B\u0430 \u0426\u0410\u041F    \nmode  = 2,\
      \    // 2 \u043A\u0430\u043D\u0430\u043B\u0430 \u0410\u0426\u041F, 1\u044B\u0439\
      \ \u043A\u0430\u043D\u0430\u043B\u0430 \u0426\u0410\u041F  \nmode = 3,    //\
      \ 2 \u043A\u0430\u043D\u0430\u043B\u0430 \u0410\u0426\u041F, 2 \u043A\u0430\u043D\
      \u0430\u043B\u0430 \u0426\u0410\u041F\nmode >= 4  // dac_mode"
    maxoutbuf: '0'
    minoutbuf: '0'
    mode: '20'
    portNumber: '7'
  states:
    _io_cache: ('Analog Digital Interface', 'ADIBlock', [('portNumber', '7'), ('mode',
      '3')], [('0', 'float', 1), ('1', 'float', 1), ('set_const_signal', 'message',
      1)], [('0', 'float', 1), ('1', 'float', 1)], '\n    Read data from serial port
      and forward it to output. \n    portNumber is number, you can see in the name
      of your \n    serial port in device manager, like COM16 or COM7 \n    ', ['mode',
      'portNumber'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1024, 240.0]
    rotation: 0
    state: enabled
- name: qtgui_time_sink_x_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '"2"'
    nconnections: '1'
    size: '1024'
    srate: '100000'
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: float
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [576, 384.0]
    rotation: 0
    state: true
- name: qtgui_time_sink_x_0_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '"Witout"'
    nconnections: '2'
    size: '1024'
    srate: '100000'
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: float
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [984, 104.0]
    rotation: 0
    state: true

connections:
- [analog_const_source_x_0, '0', blocks_unpack_k_bits_bb_0_0, '0']
- [analog_random_source_x_0, '0', blocks_null_sink_1, '0']
- [blocks_add_const_vxx_1, '0', epy_block_0, '1']
- [blocks_add_const_vxx_1, '0', qtgui_time_sink_x_0_0, '1']
- [blocks_add_const_vxx_1_0, '0', epy_block_0, '0']
- [blocks_add_const_vxx_1_0, '0', qtgui_time_sink_x_0_0, '0']
- [blocks_char_to_float_0_0_0, '0', qtgui_time_sink_x_0, '0']
- [blocks_char_to_float_0_0_0_0, '0', blocks_add_const_vxx_1_0, '0']
- [blocks_char_to_float_0_0_0_1, '0', blocks_add_const_vxx_1, '0']
- [blocks_stream_demux_0, '0', blocks_char_to_float_0_0_0_0, '0']
- [blocks_stream_demux_0, '1', blocks_char_to_float_0_0_0_1, '0']
- [blocks_unpack_k_bits_bb_0_0, '0', blocks_char_to_float_0_0_0, '0']
- [blocks_unpack_k_bits_bb_0_0, '0', blocks_stream_demux_0, '0']
- [epy_block_0, '0', blocks_null_sink_0, '0']
- [epy_block_0, '1', blocks_null_sink_0_0, '0']

metadata:
  file_format: 1
  grc_version: 3.10.8.0
