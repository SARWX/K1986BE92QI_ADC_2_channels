#include <stdint.h>

/**
 * @brief Функция для того, чтобы оставить только старшие 8 бит
 * в массиве 2ух байтных данных, с целью сжатия массива в 2 раза 
 * @param size - задается в количестве 16 битных элементов
*/
void convert_to_8_bit(uint8_t *arr, int size)
{
	// static uint8_t new_arr[NUM_OF_MES];
	for(int i = 0; i < (size*2); i++)
	{
		uint8_t high_byte = 0;
		high_byte |= ((arr[i*2] & 0xF0) >> 4);
		high_byte |= ((arr[((i*2)+1)] & 0x0F) << 4);
		arr[i] = high_byte;
	}
}

/**
 * @brief Функция-Компрессор 
 * ужимает 12 битные измерения из 2 байт в 12 бит
 * @param size - задается в количестве 16 битных элементов
*/
void convert_to_12_bit(uint8_t *arr, int size) 
{
    int i = 3, j = 4; 
    while (j < size*2)
    {
        if (((j+1)%4) == 0)
        {
            j++;
            continue;
        }
        // Возможны 2 случая:
		if ((i%2) == 0)
		{
			// Четный полубайт (младший полубайт)                                           0 - 1, 2 - 3, 4 - 5 ...
			arr[i/2] &= 0xF0;       // затерли младший полубайт
			if((j%2) == 0)
			{
			    // j тоже младший
			    arr[i/2] |= (arr[j/2] & 0x0F);
			}
			else
			{
			    // j старший
			    arr[i/2] |= ((arr[j/2] >> 4) & 0x0F);
			}
		}
		else
		{
			// Нечетный полубайт (старший полубайт)
			arr[i/2] &= 0x0F;       // затерли старший полубайт
			if((j%2) == 0)
			{
			    // j младший
			    arr[i/2] |= ((arr[j/2] << 4) & 0xF0);
			}
			else
			{
			    // j тоже старший
			    arr[i/2] |= (arr[j/2] & 0xF0);
			}
		}
		j++;
		i++;
    }
}